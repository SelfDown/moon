// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newDishType(db *gorm.DB, opts ...gen.DOOption) dishType {
	_dishType := dishType{}

	_dishType.dishTypeDo.UseDB(db, opts...)
	_dishType.dishTypeDo.UseModel(&model.DishType{})

	tableName := _dishType.dishTypeDo.TableName()
	_dishType.ALL = field.NewAsterisk(tableName)
	_dishType.DishTypeID = field.NewString(tableName, "dish_type_id")
	_dishType.Name = field.NewString(tableName, "name")
	_dishType.TypeIcon = field.NewString(tableName, "type_icon")
	_dishType.IsDefault = field.NewString(tableName, "is_default")
	_dishType.ShowComputer = field.NewString(tableName, "show_computer")
	_dishType.Tags = field.NewString(tableName, "tags")
	_dishType.Comments = field.NewString(tableName, "comments")
	_dishType.OrderIndex = field.NewInt32(tableName, "order_index")
	_dishType.Rule = field.NewString(tableName, "rule")
	_dishType.IsServerDish = field.NewString(tableName, "is_server_dish")
	_dishType.GrafanaUID = field.NewString(tableName, "grafana_uid")
	_dishType.GrafanaTitle = field.NewString(tableName, "grafana_title")
	_dishType.GrafanaURL = field.NewString(tableName, "grafana_url")
	_dishType.ProjectID = field.NewString(tableName, "project_id")
	_dishType.Pid = field.NewString(tableName, "pid")

	_dishType.fillFieldMap()

	return _dishType
}

type dishType struct {
	dishTypeDo

	ALL          field.Asterisk
	DishTypeID   field.String // 主机
	Name         field.String // 大盘类型显示名称
	TypeIcon     field.String
	IsDefault    field.String // 是否默认，1默认
	ShowComputer field.String // 是否能显示主机信息
	Tags         field.String // zabbix 面板的tag。多个以英文逗号隔开
	Comments     field.String // 备注
	OrderIndex   field.Int32
	Rule         field.String // 拼接路径替换规则
	IsServerDish field.String
	GrafanaUID   field.String
	GrafanaTitle field.String
	GrafanaURL   field.String
	ProjectID    field.String
	Pid          field.String

	fieldMap map[string]field.Expr
}

func (d dishType) Table(newTableName string) *dishType {
	d.dishTypeDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dishType) As(alias string) *dishType {
	d.dishTypeDo.DO = *(d.dishTypeDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dishType) updateTableName(table string) *dishType {
	d.ALL = field.NewAsterisk(table)
	d.DishTypeID = field.NewString(table, "dish_type_id")
	d.Name = field.NewString(table, "name")
	d.TypeIcon = field.NewString(table, "type_icon")
	d.IsDefault = field.NewString(table, "is_default")
	d.ShowComputer = field.NewString(table, "show_computer")
	d.Tags = field.NewString(table, "tags")
	d.Comments = field.NewString(table, "comments")
	d.OrderIndex = field.NewInt32(table, "order_index")
	d.Rule = field.NewString(table, "rule")
	d.IsServerDish = field.NewString(table, "is_server_dish")
	d.GrafanaUID = field.NewString(table, "grafana_uid")
	d.GrafanaTitle = field.NewString(table, "grafana_title")
	d.GrafanaURL = field.NewString(table, "grafana_url")
	d.ProjectID = field.NewString(table, "project_id")
	d.Pid = field.NewString(table, "pid")

	d.fillFieldMap()

	return d
}

func (d *dishType) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dishType) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 15)
	d.fieldMap["dish_type_id"] = d.DishTypeID
	d.fieldMap["name"] = d.Name
	d.fieldMap["type_icon"] = d.TypeIcon
	d.fieldMap["is_default"] = d.IsDefault
	d.fieldMap["show_computer"] = d.ShowComputer
	d.fieldMap["tags"] = d.Tags
	d.fieldMap["comments"] = d.Comments
	d.fieldMap["order_index"] = d.OrderIndex
	d.fieldMap["rule"] = d.Rule
	d.fieldMap["is_server_dish"] = d.IsServerDish
	d.fieldMap["grafana_uid"] = d.GrafanaUID
	d.fieldMap["grafana_title"] = d.GrafanaTitle
	d.fieldMap["grafana_url"] = d.GrafanaURL
	d.fieldMap["project_id"] = d.ProjectID
	d.fieldMap["pid"] = d.Pid
}

func (d dishType) clone(db *gorm.DB) dishType {
	d.dishTypeDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dishType) replaceDB(db *gorm.DB) dishType {
	d.dishTypeDo.ReplaceDB(db)
	return d
}

type dishTypeDo struct{ gen.DO }

type IDishTypeDo interface {
	gen.SubQuery
	Debug() IDishTypeDo
	WithContext(ctx context.Context) IDishTypeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDishTypeDo
	WriteDB() IDishTypeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDishTypeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDishTypeDo
	Not(conds ...gen.Condition) IDishTypeDo
	Or(conds ...gen.Condition) IDishTypeDo
	Select(conds ...field.Expr) IDishTypeDo
	Where(conds ...gen.Condition) IDishTypeDo
	Order(conds ...field.Expr) IDishTypeDo
	Distinct(cols ...field.Expr) IDishTypeDo
	Omit(cols ...field.Expr) IDishTypeDo
	Join(table schema.Tabler, on ...field.Expr) IDishTypeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDishTypeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDishTypeDo
	Group(cols ...field.Expr) IDishTypeDo
	Having(conds ...gen.Condition) IDishTypeDo
	Limit(limit int) IDishTypeDo
	Offset(offset int) IDishTypeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDishTypeDo
	Unscoped() IDishTypeDo
	Create(values ...*model.DishType) error
	CreateInBatches(values []*model.DishType, batchSize int) error
	Save(values ...*model.DishType) error
	First() (*model.DishType, error)
	Take() (*model.DishType, error)
	Last() (*model.DishType, error)
	Find() ([]*model.DishType, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DishType, err error)
	FindInBatches(result *[]*model.DishType, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DishType) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDishTypeDo
	Assign(attrs ...field.AssignExpr) IDishTypeDo
	Joins(fields ...field.RelationField) IDishTypeDo
	Preload(fields ...field.RelationField) IDishTypeDo
	FirstOrInit() (*model.DishType, error)
	FirstOrCreate() (*model.DishType, error)
	FindByPage(offset int, limit int) (result []*model.DishType, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDishTypeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dishTypeDo) Debug() IDishTypeDo {
	return d.withDO(d.DO.Debug())
}

func (d dishTypeDo) WithContext(ctx context.Context) IDishTypeDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dishTypeDo) ReadDB() IDishTypeDo {
	return d.Clauses(dbresolver.Read)
}

func (d dishTypeDo) WriteDB() IDishTypeDo {
	return d.Clauses(dbresolver.Write)
}

func (d dishTypeDo) Session(config *gorm.Session) IDishTypeDo {
	return d.withDO(d.DO.Session(config))
}

func (d dishTypeDo) Clauses(conds ...clause.Expression) IDishTypeDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dishTypeDo) Returning(value interface{}, columns ...string) IDishTypeDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dishTypeDo) Not(conds ...gen.Condition) IDishTypeDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dishTypeDo) Or(conds ...gen.Condition) IDishTypeDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dishTypeDo) Select(conds ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dishTypeDo) Where(conds ...gen.Condition) IDishTypeDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dishTypeDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDishTypeDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d dishTypeDo) Order(conds ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dishTypeDo) Distinct(cols ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dishTypeDo) Omit(cols ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dishTypeDo) Join(table schema.Tabler, on ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dishTypeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dishTypeDo) RightJoin(table schema.Tabler, on ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dishTypeDo) Group(cols ...field.Expr) IDishTypeDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dishTypeDo) Having(conds ...gen.Condition) IDishTypeDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dishTypeDo) Limit(limit int) IDishTypeDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dishTypeDo) Offset(offset int) IDishTypeDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dishTypeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDishTypeDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dishTypeDo) Unscoped() IDishTypeDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dishTypeDo) Create(values ...*model.DishType) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dishTypeDo) CreateInBatches(values []*model.DishType, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dishTypeDo) Save(values ...*model.DishType) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dishTypeDo) First() (*model.DishType, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DishType), nil
	}
}

func (d dishTypeDo) Take() (*model.DishType, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DishType), nil
	}
}

func (d dishTypeDo) Last() (*model.DishType, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DishType), nil
	}
}

func (d dishTypeDo) Find() ([]*model.DishType, error) {
	result, err := d.DO.Find()
	return result.([]*model.DishType), err
}

func (d dishTypeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DishType, err error) {
	buf := make([]*model.DishType, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dishTypeDo) FindInBatches(result *[]*model.DishType, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dishTypeDo) Attrs(attrs ...field.AssignExpr) IDishTypeDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dishTypeDo) Assign(attrs ...field.AssignExpr) IDishTypeDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dishTypeDo) Joins(fields ...field.RelationField) IDishTypeDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dishTypeDo) Preload(fields ...field.RelationField) IDishTypeDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dishTypeDo) FirstOrInit() (*model.DishType, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DishType), nil
	}
}

func (d dishTypeDo) FirstOrCreate() (*model.DishType, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DishType), nil
	}
}

func (d dishTypeDo) FindByPage(offset int, limit int) (result []*model.DishType, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dishTypeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dishTypeDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dishTypeDo) Delete(models ...*model.DishType) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dishTypeDo) withDO(do gen.Dao) *dishTypeDo {
	d.DO = *do.(*gen.DO)
	return d
}
