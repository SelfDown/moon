// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newDjangoApschedulerDjangojob(db *gorm.DB, opts ...gen.DOOption) djangoApschedulerDjangojob {
	_djangoApschedulerDjangojob := djangoApschedulerDjangojob{}

	_djangoApschedulerDjangojob.djangoApschedulerDjangojobDo.UseDB(db, opts...)
	_djangoApschedulerDjangojob.djangoApschedulerDjangojobDo.UseModel(&model.DjangoApschedulerDjangojob{})

	tableName := _djangoApschedulerDjangojob.djangoApschedulerDjangojobDo.TableName()
	_djangoApschedulerDjangojob.ALL = field.NewAsterisk(tableName)
	_djangoApschedulerDjangojob.ID = field.NewInt32(tableName, "id")
	_djangoApschedulerDjangojob.Name = field.NewString(tableName, "name")
	_djangoApschedulerDjangojob.NextRunTime = field.NewTime(tableName, "next_run_time")
	_djangoApschedulerDjangojob.JobState = field.NewBytes(tableName, "job_state")

	_djangoApschedulerDjangojob.fillFieldMap()

	return _djangoApschedulerDjangojob
}

type djangoApschedulerDjangojob struct {
	djangoApschedulerDjangojobDo

	ALL         field.Asterisk
	ID          field.Int32
	Name        field.String
	NextRunTime field.Time
	JobState    field.Bytes

	fieldMap map[string]field.Expr
}

func (d djangoApschedulerDjangojob) Table(newTableName string) *djangoApschedulerDjangojob {
	d.djangoApschedulerDjangojobDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d djangoApschedulerDjangojob) As(alias string) *djangoApschedulerDjangojob {
	d.djangoApschedulerDjangojobDo.DO = *(d.djangoApschedulerDjangojobDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *djangoApschedulerDjangojob) updateTableName(table string) *djangoApschedulerDjangojob {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt32(table, "id")
	d.Name = field.NewString(table, "name")
	d.NextRunTime = field.NewTime(table, "next_run_time")
	d.JobState = field.NewBytes(table, "job_state")

	d.fillFieldMap()

	return d
}

func (d *djangoApschedulerDjangojob) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *djangoApschedulerDjangojob) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 4)
	d.fieldMap["id"] = d.ID
	d.fieldMap["name"] = d.Name
	d.fieldMap["next_run_time"] = d.NextRunTime
	d.fieldMap["job_state"] = d.JobState
}

func (d djangoApschedulerDjangojob) clone(db *gorm.DB) djangoApschedulerDjangojob {
	d.djangoApschedulerDjangojobDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d djangoApschedulerDjangojob) replaceDB(db *gorm.DB) djangoApschedulerDjangojob {
	d.djangoApschedulerDjangojobDo.ReplaceDB(db)
	return d
}

type djangoApschedulerDjangojobDo struct{ gen.DO }

type IDjangoApschedulerDjangojobDo interface {
	gen.SubQuery
	Debug() IDjangoApschedulerDjangojobDo
	WithContext(ctx context.Context) IDjangoApschedulerDjangojobDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDjangoApschedulerDjangojobDo
	WriteDB() IDjangoApschedulerDjangojobDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDjangoApschedulerDjangojobDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDjangoApschedulerDjangojobDo
	Not(conds ...gen.Condition) IDjangoApschedulerDjangojobDo
	Or(conds ...gen.Condition) IDjangoApschedulerDjangojobDo
	Select(conds ...field.Expr) IDjangoApschedulerDjangojobDo
	Where(conds ...gen.Condition) IDjangoApschedulerDjangojobDo
	Order(conds ...field.Expr) IDjangoApschedulerDjangojobDo
	Distinct(cols ...field.Expr) IDjangoApschedulerDjangojobDo
	Omit(cols ...field.Expr) IDjangoApschedulerDjangojobDo
	Join(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo
	Group(cols ...field.Expr) IDjangoApschedulerDjangojobDo
	Having(conds ...gen.Condition) IDjangoApschedulerDjangojobDo
	Limit(limit int) IDjangoApschedulerDjangojobDo
	Offset(offset int) IDjangoApschedulerDjangojobDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDjangoApschedulerDjangojobDo
	Unscoped() IDjangoApschedulerDjangojobDo
	Create(values ...*model.DjangoApschedulerDjangojob) error
	CreateInBatches(values []*model.DjangoApschedulerDjangojob, batchSize int) error
	Save(values ...*model.DjangoApschedulerDjangojob) error
	First() (*model.DjangoApschedulerDjangojob, error)
	Take() (*model.DjangoApschedulerDjangojob, error)
	Last() (*model.DjangoApschedulerDjangojob, error)
	Find() ([]*model.DjangoApschedulerDjangojob, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DjangoApschedulerDjangojob, err error)
	FindInBatches(result *[]*model.DjangoApschedulerDjangojob, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DjangoApschedulerDjangojob) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDjangoApschedulerDjangojobDo
	Assign(attrs ...field.AssignExpr) IDjangoApschedulerDjangojobDo
	Joins(fields ...field.RelationField) IDjangoApschedulerDjangojobDo
	Preload(fields ...field.RelationField) IDjangoApschedulerDjangojobDo
	FirstOrInit() (*model.DjangoApschedulerDjangojob, error)
	FirstOrCreate() (*model.DjangoApschedulerDjangojob, error)
	FindByPage(offset int, limit int) (result []*model.DjangoApschedulerDjangojob, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDjangoApschedulerDjangojobDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d djangoApschedulerDjangojobDo) Debug() IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Debug())
}

func (d djangoApschedulerDjangojobDo) WithContext(ctx context.Context) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d djangoApschedulerDjangojobDo) ReadDB() IDjangoApschedulerDjangojobDo {
	return d.Clauses(dbresolver.Read)
}

func (d djangoApschedulerDjangojobDo) WriteDB() IDjangoApschedulerDjangojobDo {
	return d.Clauses(dbresolver.Write)
}

func (d djangoApschedulerDjangojobDo) Session(config *gorm.Session) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Session(config))
}

func (d djangoApschedulerDjangojobDo) Clauses(conds ...clause.Expression) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d djangoApschedulerDjangojobDo) Returning(value interface{}, columns ...string) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d djangoApschedulerDjangojobDo) Not(conds ...gen.Condition) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d djangoApschedulerDjangojobDo) Or(conds ...gen.Condition) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d djangoApschedulerDjangojobDo) Select(conds ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d djangoApschedulerDjangojobDo) Where(conds ...gen.Condition) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d djangoApschedulerDjangojobDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDjangoApschedulerDjangojobDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d djangoApschedulerDjangojobDo) Order(conds ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d djangoApschedulerDjangojobDo) Distinct(cols ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d djangoApschedulerDjangojobDo) Omit(cols ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d djangoApschedulerDjangojobDo) Join(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d djangoApschedulerDjangojobDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d djangoApschedulerDjangojobDo) RightJoin(table schema.Tabler, on ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d djangoApschedulerDjangojobDo) Group(cols ...field.Expr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d djangoApschedulerDjangojobDo) Having(conds ...gen.Condition) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d djangoApschedulerDjangojobDo) Limit(limit int) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d djangoApschedulerDjangojobDo) Offset(offset int) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d djangoApschedulerDjangojobDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d djangoApschedulerDjangojobDo) Unscoped() IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Unscoped())
}

func (d djangoApschedulerDjangojobDo) Create(values ...*model.DjangoApschedulerDjangojob) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d djangoApschedulerDjangojobDo) CreateInBatches(values []*model.DjangoApschedulerDjangojob, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d djangoApschedulerDjangojobDo) Save(values ...*model.DjangoApschedulerDjangojob) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d djangoApschedulerDjangojobDo) First() (*model.DjangoApschedulerDjangojob, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoApschedulerDjangojob), nil
	}
}

func (d djangoApschedulerDjangojobDo) Take() (*model.DjangoApschedulerDjangojob, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoApschedulerDjangojob), nil
	}
}

func (d djangoApschedulerDjangojobDo) Last() (*model.DjangoApschedulerDjangojob, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoApschedulerDjangojob), nil
	}
}

func (d djangoApschedulerDjangojobDo) Find() ([]*model.DjangoApschedulerDjangojob, error) {
	result, err := d.DO.Find()
	return result.([]*model.DjangoApschedulerDjangojob), err
}

func (d djangoApschedulerDjangojobDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DjangoApschedulerDjangojob, err error) {
	buf := make([]*model.DjangoApschedulerDjangojob, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d djangoApschedulerDjangojobDo) FindInBatches(result *[]*model.DjangoApschedulerDjangojob, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d djangoApschedulerDjangojobDo) Attrs(attrs ...field.AssignExpr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d djangoApschedulerDjangojobDo) Assign(attrs ...field.AssignExpr) IDjangoApschedulerDjangojobDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d djangoApschedulerDjangojobDo) Joins(fields ...field.RelationField) IDjangoApschedulerDjangojobDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d djangoApschedulerDjangojobDo) Preload(fields ...field.RelationField) IDjangoApschedulerDjangojobDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d djangoApschedulerDjangojobDo) FirstOrInit() (*model.DjangoApschedulerDjangojob, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoApschedulerDjangojob), nil
	}
}

func (d djangoApschedulerDjangojobDo) FirstOrCreate() (*model.DjangoApschedulerDjangojob, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoApschedulerDjangojob), nil
	}
}

func (d djangoApschedulerDjangojobDo) FindByPage(offset int, limit int) (result []*model.DjangoApschedulerDjangojob, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d djangoApschedulerDjangojobDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d djangoApschedulerDjangojobDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d djangoApschedulerDjangojobDo) Delete(models ...*model.DjangoApschedulerDjangojob) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *djangoApschedulerDjangojobDo) withDO(do gen.Dao) *djangoApschedulerDjangojobDo {
	d.DO = *do.(*gen.DO)
	return d
}
