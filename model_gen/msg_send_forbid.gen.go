// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newMsgSendForbid(db *gorm.DB, opts ...gen.DOOption) msgSendForbid {
	_msgSendForbid := msgSendForbid{}

	_msgSendForbid.msgSendForbidDo.UseDB(db, opts...)
	_msgSendForbid.msgSendForbidDo.UseModel(&model.MsgSendForbid{})

	tableName := _msgSendForbid.msgSendForbidDo.TableName()
	_msgSendForbid.ALL = field.NewAsterisk(tableName)
	_msgSendForbid.MsgSendForbidID = field.NewString(tableName, "msg_send_forbid_id")
	_msgSendForbid.AlertitemCodeStr = field.NewString(tableName, "alertitem_code_str")
	_msgSendForbid.IPStr = field.NewString(tableName, "ip_str")
	_msgSendForbid.MachineNameStr = field.NewString(tableName, "machine_name_str")
	_msgSendForbid.ChannelIDStr = field.NewString(tableName, "channel_id_str")
	_msgSendForbid.MsgContentStr = field.NewString(tableName, "msg_content_str")
	_msgSendForbid.TimeBegin = field.NewTime(tableName, "time_begin")
	_msgSendForbid.TimeEnd = field.NewTime(tableName, "time_end")
	_msgSendForbid.ForbidType = field.NewString(tableName, "forbid_type")
	_msgSendForbid.AddTime = field.NewTime(tableName, "add_time")
	_msgSendForbid.AddUser = field.NewString(tableName, "add_user")
	_msgSendForbid.ProjectCodeStr = field.NewString(tableName, "project_code_str")

	_msgSendForbid.fillFieldMap()

	return _msgSendForbid
}

type msgSendForbid struct {
	msgSendForbidDo

	ALL              field.Asterisk
	MsgSendForbidID  field.String // 禁用ID
	AlertitemCodeStr field.String // 禁用预警编码，多个以逗号分隔
	IPStr            field.String // 禁用主机IP，多个以逗号分隔
	MachineNameStr   field.String // 禁用主机名包含，多个@分隔
	ChannelIDStr     field.String // 应用通道，通道ID多个逗号分隔
	MsgContentStr    field.String // 禁用消息体包含，多个@分隔
	TimeBegin        field.Time
	TimeEnd          field.Time
	ForbidType       field.String
	AddTime          field.Time
	AddUser          field.String
	ProjectCodeStr   field.String // 限定项目编码，多个逗号分隔

	fieldMap map[string]field.Expr
}

func (m msgSendForbid) Table(newTableName string) *msgSendForbid {
	m.msgSendForbidDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m msgSendForbid) As(alias string) *msgSendForbid {
	m.msgSendForbidDo.DO = *(m.msgSendForbidDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *msgSendForbid) updateTableName(table string) *msgSendForbid {
	m.ALL = field.NewAsterisk(table)
	m.MsgSendForbidID = field.NewString(table, "msg_send_forbid_id")
	m.AlertitemCodeStr = field.NewString(table, "alertitem_code_str")
	m.IPStr = field.NewString(table, "ip_str")
	m.MachineNameStr = field.NewString(table, "machine_name_str")
	m.ChannelIDStr = field.NewString(table, "channel_id_str")
	m.MsgContentStr = field.NewString(table, "msg_content_str")
	m.TimeBegin = field.NewTime(table, "time_begin")
	m.TimeEnd = field.NewTime(table, "time_end")
	m.ForbidType = field.NewString(table, "forbid_type")
	m.AddTime = field.NewTime(table, "add_time")
	m.AddUser = field.NewString(table, "add_user")
	m.ProjectCodeStr = field.NewString(table, "project_code_str")

	m.fillFieldMap()

	return m
}

func (m *msgSendForbid) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *msgSendForbid) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 12)
	m.fieldMap["msg_send_forbid_id"] = m.MsgSendForbidID
	m.fieldMap["alertitem_code_str"] = m.AlertitemCodeStr
	m.fieldMap["ip_str"] = m.IPStr
	m.fieldMap["machine_name_str"] = m.MachineNameStr
	m.fieldMap["channel_id_str"] = m.ChannelIDStr
	m.fieldMap["msg_content_str"] = m.MsgContentStr
	m.fieldMap["time_begin"] = m.TimeBegin
	m.fieldMap["time_end"] = m.TimeEnd
	m.fieldMap["forbid_type"] = m.ForbidType
	m.fieldMap["add_time"] = m.AddTime
	m.fieldMap["add_user"] = m.AddUser
	m.fieldMap["project_code_str"] = m.ProjectCodeStr
}

func (m msgSendForbid) clone(db *gorm.DB) msgSendForbid {
	m.msgSendForbidDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m msgSendForbid) replaceDB(db *gorm.DB) msgSendForbid {
	m.msgSendForbidDo.ReplaceDB(db)
	return m
}

type msgSendForbidDo struct{ gen.DO }

type IMsgSendForbidDo interface {
	gen.SubQuery
	Debug() IMsgSendForbidDo
	WithContext(ctx context.Context) IMsgSendForbidDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMsgSendForbidDo
	WriteDB() IMsgSendForbidDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMsgSendForbidDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMsgSendForbidDo
	Not(conds ...gen.Condition) IMsgSendForbidDo
	Or(conds ...gen.Condition) IMsgSendForbidDo
	Select(conds ...field.Expr) IMsgSendForbidDo
	Where(conds ...gen.Condition) IMsgSendForbidDo
	Order(conds ...field.Expr) IMsgSendForbidDo
	Distinct(cols ...field.Expr) IMsgSendForbidDo
	Omit(cols ...field.Expr) IMsgSendForbidDo
	Join(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo
	Group(cols ...field.Expr) IMsgSendForbidDo
	Having(conds ...gen.Condition) IMsgSendForbidDo
	Limit(limit int) IMsgSendForbidDo
	Offset(offset int) IMsgSendForbidDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMsgSendForbidDo
	Unscoped() IMsgSendForbidDo
	Create(values ...*model.MsgSendForbid) error
	CreateInBatches(values []*model.MsgSendForbid, batchSize int) error
	Save(values ...*model.MsgSendForbid) error
	First() (*model.MsgSendForbid, error)
	Take() (*model.MsgSendForbid, error)
	Last() (*model.MsgSendForbid, error)
	Find() ([]*model.MsgSendForbid, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MsgSendForbid, err error)
	FindInBatches(result *[]*model.MsgSendForbid, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MsgSendForbid) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMsgSendForbidDo
	Assign(attrs ...field.AssignExpr) IMsgSendForbidDo
	Joins(fields ...field.RelationField) IMsgSendForbidDo
	Preload(fields ...field.RelationField) IMsgSendForbidDo
	FirstOrInit() (*model.MsgSendForbid, error)
	FirstOrCreate() (*model.MsgSendForbid, error)
	FindByPage(offset int, limit int) (result []*model.MsgSendForbid, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMsgSendForbidDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m msgSendForbidDo) Debug() IMsgSendForbidDo {
	return m.withDO(m.DO.Debug())
}

func (m msgSendForbidDo) WithContext(ctx context.Context) IMsgSendForbidDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m msgSendForbidDo) ReadDB() IMsgSendForbidDo {
	return m.Clauses(dbresolver.Read)
}

func (m msgSendForbidDo) WriteDB() IMsgSendForbidDo {
	return m.Clauses(dbresolver.Write)
}

func (m msgSendForbidDo) Session(config *gorm.Session) IMsgSendForbidDo {
	return m.withDO(m.DO.Session(config))
}

func (m msgSendForbidDo) Clauses(conds ...clause.Expression) IMsgSendForbidDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m msgSendForbidDo) Returning(value interface{}, columns ...string) IMsgSendForbidDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m msgSendForbidDo) Not(conds ...gen.Condition) IMsgSendForbidDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m msgSendForbidDo) Or(conds ...gen.Condition) IMsgSendForbidDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m msgSendForbidDo) Select(conds ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m msgSendForbidDo) Where(conds ...gen.Condition) IMsgSendForbidDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m msgSendForbidDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IMsgSendForbidDo {
	return m.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (m msgSendForbidDo) Order(conds ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m msgSendForbidDo) Distinct(cols ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m msgSendForbidDo) Omit(cols ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m msgSendForbidDo) Join(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m msgSendForbidDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m msgSendForbidDo) RightJoin(table schema.Tabler, on ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m msgSendForbidDo) Group(cols ...field.Expr) IMsgSendForbidDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m msgSendForbidDo) Having(conds ...gen.Condition) IMsgSendForbidDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m msgSendForbidDo) Limit(limit int) IMsgSendForbidDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m msgSendForbidDo) Offset(offset int) IMsgSendForbidDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m msgSendForbidDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMsgSendForbidDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m msgSendForbidDo) Unscoped() IMsgSendForbidDo {
	return m.withDO(m.DO.Unscoped())
}

func (m msgSendForbidDo) Create(values ...*model.MsgSendForbid) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m msgSendForbidDo) CreateInBatches(values []*model.MsgSendForbid, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m msgSendForbidDo) Save(values ...*model.MsgSendForbid) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m msgSendForbidDo) First() (*model.MsgSendForbid, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MsgSendForbid), nil
	}
}

func (m msgSendForbidDo) Take() (*model.MsgSendForbid, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MsgSendForbid), nil
	}
}

func (m msgSendForbidDo) Last() (*model.MsgSendForbid, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MsgSendForbid), nil
	}
}

func (m msgSendForbidDo) Find() ([]*model.MsgSendForbid, error) {
	result, err := m.DO.Find()
	return result.([]*model.MsgSendForbid), err
}

func (m msgSendForbidDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MsgSendForbid, err error) {
	buf := make([]*model.MsgSendForbid, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m msgSendForbidDo) FindInBatches(result *[]*model.MsgSendForbid, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m msgSendForbidDo) Attrs(attrs ...field.AssignExpr) IMsgSendForbidDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m msgSendForbidDo) Assign(attrs ...field.AssignExpr) IMsgSendForbidDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m msgSendForbidDo) Joins(fields ...field.RelationField) IMsgSendForbidDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m msgSendForbidDo) Preload(fields ...field.RelationField) IMsgSendForbidDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m msgSendForbidDo) FirstOrInit() (*model.MsgSendForbid, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MsgSendForbid), nil
	}
}

func (m msgSendForbidDo) FirstOrCreate() (*model.MsgSendForbid, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MsgSendForbid), nil
	}
}

func (m msgSendForbidDo) FindByPage(offset int, limit int) (result []*model.MsgSendForbid, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m msgSendForbidDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m msgSendForbidDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m msgSendForbidDo) Delete(models ...*model.MsgSendForbid) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *msgSendForbidDo) withDO(do gen.Dao) *msgSendForbidDo {
	m.DO = *do.(*gen.DO)
	return m
}
