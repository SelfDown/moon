// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newOpenJobList(db *gorm.DB, opts ...gen.DOOption) openJobList {
	_openJobList := openJobList{}

	_openJobList.openJobListDo.UseDB(db, opts...)
	_openJobList.openJobListDo.UseModel(&model.OpenJobList{})

	tableName := _openJobList.openJobListDo.TableName()
	_openJobList.ALL = field.NewAsterisk(tableName)
	_openJobList.JobID = field.NewString(tableName, "job_id")
	_openJobList.OpenJobStatus = field.NewString(tableName, "open_job_status")
	_openJobList.OpenAPIURL = field.NewString(tableName, "open_api_url")
	_openJobList.OpUserID = field.NewString(tableName, "op_user_id")
	_openJobList.ServerEnvID = field.NewString(tableName, "server_env_id")
	_openJobList.RunTime = field.NewTime(tableName, "run_time")
	_openJobList.NowRun = field.NewString(tableName, "now_run")
	_openJobList.ExecutionCycle = field.NewInt32(tableName, "execution cycle")
	_openJobList.JobValidity = field.NewString(tableName, "job_validity")
	_openJobList.OpenJobEventID = field.NewString(tableName, "open_job_event_id")
	_openJobList.SysProjectID = field.NewString(tableName, "sys_project_id")
	_openJobList.ActionCodeID = field.NewString(tableName, "action_code_id")
	_openJobList.ActionOpObjID = field.NewString(tableName, "action_op_obj_id")
	_openJobList.BatchID = field.NewString(tableName, "batch_id")
	_openJobList.JobNote = field.NewString(tableName, "job_note")
	_openJobList.CreateTime = field.NewTime(tableName, "create_time")
	_openJobList.ModifyTime = field.NewTime(tableName, "modify_time")
	_openJobList.Comments = field.NewString(tableName, "comments")

	_openJobList.fillFieldMap()

	return _openJobList
}

type openJobList struct {
	openJobListDo

	ALL   field.Asterisk
	JobID field.String // job_id
	/*
		任务状态
		sys_code.sys_code_type='open_job_status'
	*/
	OpenJobStatus  field.String
	OpenAPIURL     field.String
	OpUserID       field.String // 操作人
	ServerEnvID    field.String
	RunTime        field.Time   // 任务执行时间
	NowRun         field.String // 是否立即执行 1、立即执行  其他：否
	ExecutionCycle field.Int32  // 执行周期,分钟
	JobValidity    field.String // 任务是否被禁止，1禁止，0开启
	OpenJobEventID field.String // 任务事件ID
	SysProjectID   field.String // 项目点ID
	ActionCodeID   field.String // sys_code.sys_type="open_job_action'
	ActionOpObjID  field.String // 被执行对象的主键
	BatchID        field.String // 批次ID；一个批次号可以对应一到多个job_id
	JobNote        field.String // 任务说明
	CreateTime     field.Time   // 记录创建时间（数据库自动写入）
	ModifyTime     field.Time   // 记录修改时间（数据库自动写入）
	Comments       field.String // 备注说明

	fieldMap map[string]field.Expr
}

func (o openJobList) Table(newTableName string) *openJobList {
	o.openJobListDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o openJobList) As(alias string) *openJobList {
	o.openJobListDo.DO = *(o.openJobListDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *openJobList) updateTableName(table string) *openJobList {
	o.ALL = field.NewAsterisk(table)
	o.JobID = field.NewString(table, "job_id")
	o.OpenJobStatus = field.NewString(table, "open_job_status")
	o.OpenAPIURL = field.NewString(table, "open_api_url")
	o.OpUserID = field.NewString(table, "op_user_id")
	o.ServerEnvID = field.NewString(table, "server_env_id")
	o.RunTime = field.NewTime(table, "run_time")
	o.NowRun = field.NewString(table, "now_run")
	o.ExecutionCycle = field.NewInt32(table, "execution cycle")
	o.JobValidity = field.NewString(table, "job_validity")
	o.OpenJobEventID = field.NewString(table, "open_job_event_id")
	o.SysProjectID = field.NewString(table, "sys_project_id")
	o.ActionCodeID = field.NewString(table, "action_code_id")
	o.ActionOpObjID = field.NewString(table, "action_op_obj_id")
	o.BatchID = field.NewString(table, "batch_id")
	o.JobNote = field.NewString(table, "job_note")
	o.CreateTime = field.NewTime(table, "create_time")
	o.ModifyTime = field.NewTime(table, "modify_time")
	o.Comments = field.NewString(table, "comments")

	o.fillFieldMap()

	return o
}

func (o *openJobList) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *openJobList) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 18)
	o.fieldMap["job_id"] = o.JobID
	o.fieldMap["open_job_status"] = o.OpenJobStatus
	o.fieldMap["open_api_url"] = o.OpenAPIURL
	o.fieldMap["op_user_id"] = o.OpUserID
	o.fieldMap["server_env_id"] = o.ServerEnvID
	o.fieldMap["run_time"] = o.RunTime
	o.fieldMap["now_run"] = o.NowRun
	o.fieldMap["execution cycle"] = o.ExecutionCycle
	o.fieldMap["job_validity"] = o.JobValidity
	o.fieldMap["open_job_event_id"] = o.OpenJobEventID
	o.fieldMap["sys_project_id"] = o.SysProjectID
	o.fieldMap["action_code_id"] = o.ActionCodeID
	o.fieldMap["action_op_obj_id"] = o.ActionOpObjID
	o.fieldMap["batch_id"] = o.BatchID
	o.fieldMap["job_note"] = o.JobNote
	o.fieldMap["create_time"] = o.CreateTime
	o.fieldMap["modify_time"] = o.ModifyTime
	o.fieldMap["comments"] = o.Comments
}

func (o openJobList) clone(db *gorm.DB) openJobList {
	o.openJobListDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o openJobList) replaceDB(db *gorm.DB) openJobList {
	o.openJobListDo.ReplaceDB(db)
	return o
}

type openJobListDo struct{ gen.DO }

type IOpenJobListDo interface {
	gen.SubQuery
	Debug() IOpenJobListDo
	WithContext(ctx context.Context) IOpenJobListDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOpenJobListDo
	WriteDB() IOpenJobListDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOpenJobListDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOpenJobListDo
	Not(conds ...gen.Condition) IOpenJobListDo
	Or(conds ...gen.Condition) IOpenJobListDo
	Select(conds ...field.Expr) IOpenJobListDo
	Where(conds ...gen.Condition) IOpenJobListDo
	Order(conds ...field.Expr) IOpenJobListDo
	Distinct(cols ...field.Expr) IOpenJobListDo
	Omit(cols ...field.Expr) IOpenJobListDo
	Join(table schema.Tabler, on ...field.Expr) IOpenJobListDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOpenJobListDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOpenJobListDo
	Group(cols ...field.Expr) IOpenJobListDo
	Having(conds ...gen.Condition) IOpenJobListDo
	Limit(limit int) IOpenJobListDo
	Offset(offset int) IOpenJobListDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOpenJobListDo
	Unscoped() IOpenJobListDo
	Create(values ...*model.OpenJobList) error
	CreateInBatches(values []*model.OpenJobList, batchSize int) error
	Save(values ...*model.OpenJobList) error
	First() (*model.OpenJobList, error)
	Take() (*model.OpenJobList, error)
	Last() (*model.OpenJobList, error)
	Find() ([]*model.OpenJobList, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OpenJobList, err error)
	FindInBatches(result *[]*model.OpenJobList, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OpenJobList) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOpenJobListDo
	Assign(attrs ...field.AssignExpr) IOpenJobListDo
	Joins(fields ...field.RelationField) IOpenJobListDo
	Preload(fields ...field.RelationField) IOpenJobListDo
	FirstOrInit() (*model.OpenJobList, error)
	FirstOrCreate() (*model.OpenJobList, error)
	FindByPage(offset int, limit int) (result []*model.OpenJobList, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOpenJobListDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o openJobListDo) Debug() IOpenJobListDo {
	return o.withDO(o.DO.Debug())
}

func (o openJobListDo) WithContext(ctx context.Context) IOpenJobListDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o openJobListDo) ReadDB() IOpenJobListDo {
	return o.Clauses(dbresolver.Read)
}

func (o openJobListDo) WriteDB() IOpenJobListDo {
	return o.Clauses(dbresolver.Write)
}

func (o openJobListDo) Session(config *gorm.Session) IOpenJobListDo {
	return o.withDO(o.DO.Session(config))
}

func (o openJobListDo) Clauses(conds ...clause.Expression) IOpenJobListDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o openJobListDo) Returning(value interface{}, columns ...string) IOpenJobListDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o openJobListDo) Not(conds ...gen.Condition) IOpenJobListDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o openJobListDo) Or(conds ...gen.Condition) IOpenJobListDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o openJobListDo) Select(conds ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o openJobListDo) Where(conds ...gen.Condition) IOpenJobListDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o openJobListDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IOpenJobListDo {
	return o.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (o openJobListDo) Order(conds ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o openJobListDo) Distinct(cols ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o openJobListDo) Omit(cols ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o openJobListDo) Join(table schema.Tabler, on ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o openJobListDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o openJobListDo) RightJoin(table schema.Tabler, on ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o openJobListDo) Group(cols ...field.Expr) IOpenJobListDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o openJobListDo) Having(conds ...gen.Condition) IOpenJobListDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o openJobListDo) Limit(limit int) IOpenJobListDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o openJobListDo) Offset(offset int) IOpenJobListDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o openJobListDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOpenJobListDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o openJobListDo) Unscoped() IOpenJobListDo {
	return o.withDO(o.DO.Unscoped())
}

func (o openJobListDo) Create(values ...*model.OpenJobList) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o openJobListDo) CreateInBatches(values []*model.OpenJobList, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o openJobListDo) Save(values ...*model.OpenJobList) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o openJobListDo) First() (*model.OpenJobList, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpenJobList), nil
	}
}

func (o openJobListDo) Take() (*model.OpenJobList, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpenJobList), nil
	}
}

func (o openJobListDo) Last() (*model.OpenJobList, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpenJobList), nil
	}
}

func (o openJobListDo) Find() ([]*model.OpenJobList, error) {
	result, err := o.DO.Find()
	return result.([]*model.OpenJobList), err
}

func (o openJobListDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OpenJobList, err error) {
	buf := make([]*model.OpenJobList, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o openJobListDo) FindInBatches(result *[]*model.OpenJobList, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o openJobListDo) Attrs(attrs ...field.AssignExpr) IOpenJobListDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o openJobListDo) Assign(attrs ...field.AssignExpr) IOpenJobListDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o openJobListDo) Joins(fields ...field.RelationField) IOpenJobListDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o openJobListDo) Preload(fields ...field.RelationField) IOpenJobListDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o openJobListDo) FirstOrInit() (*model.OpenJobList, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpenJobList), nil
	}
}

func (o openJobListDo) FirstOrCreate() (*model.OpenJobList, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpenJobList), nil
	}
}

func (o openJobListDo) FindByPage(offset int, limit int) (result []*model.OpenJobList, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o openJobListDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o openJobListDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o openJobListDo) Delete(models ...*model.OpenJobList) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *openJobListDo) withDO(do gen.Dao) *openJobListDo {
	o.DO = *do.(*gen.DO)
	return o
}
