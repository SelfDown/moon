// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newOracleInstance(db *gorm.DB, opts ...gen.DOOption) oracleInstance {
	_oracleInstance := oracleInstance{}

	_oracleInstance.oracleInstanceDo.UseDB(db, opts...)
	_oracleInstance.oracleInstanceDo.UseModel(&model.OracleInstance{})

	tableName := _oracleInstance.oracleInstanceDo.TableName()
	_oracleInstance.ALL = field.NewAsterisk(tableName)
	_oracleInstance.OracleInstanceID = field.NewString(tableName, "oracle_instance_id")
	_oracleInstance.ServerID = field.NewString(tableName, "server_id")
	_oracleInstance.CreateTime = field.NewTime(tableName, "create_time")
	_oracleInstance.ModifyTime = field.NewTime(tableName, "modify_time")
	_oracleInstance.Comments = field.NewString(tableName, "comments")
	_oracleInstance.DbUser = field.NewString(tableName, "db_user")
	_oracleInstance.DbPwd = field.NewString(tableName, "db_pwd")
	_oracleInstance.Sid = field.NewString(tableName, "sid")
	_oracleInstance.ServerName = field.NewString(tableName, "server_name")
	_oracleInstance.OracleVersion = field.NewString(tableName, "oracle_version")
	_oracleInstance.SqlAdminRoleID = field.NewString(tableName, "sql_admin_role_id")
	_oracleInstance.DbPwdBackup = field.NewString(tableName, "db_pwd_backup")
	_oracleInstance.Dbkey = field.NewString(tableName, "dbkey")

	_oracleInstance.fillFieldMap()

	return _oracleInstance
}

type oracleInstance struct {
	oracleInstanceDo

	ALL              field.Asterisk
	OracleInstanceID field.String
	ServerID         field.String
	CreateTime       field.Time   // 记录创建时间（数据库自动写入）
	ModifyTime       field.Time   // 记录修改时间（数据库自动写入）
	Comments         field.String // 备注说明
	DbUser           field.String
	DbPwd            field.String
	Sid              field.String
	ServerName       field.String
	OracleVersion    field.String // oracle版本
	SqlAdminRoleID   field.String
	DbPwdBackup      field.String // 临时备份，加密无误后要删除该字段
	/*
		dbkey 当前登录数据库需要被缓存的数据库key

		这个key目前可选值为 HIS EIF HRP 三个，这个值一般会配置到oracle_instance数据库某个字段，上面的三个类型的库若在实际场景中是分开数据库或者分开实例部署的就需要区别传入，比如同济生产 EIF库是单独部署的，那么EIF的oracle_instance总要配置key为EIF，若这个值不传入将默认为HIS
	*/
	Dbkey field.String

	fieldMap map[string]field.Expr
}

func (o oracleInstance) Table(newTableName string) *oracleInstance {
	o.oracleInstanceDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o oracleInstance) As(alias string) *oracleInstance {
	o.oracleInstanceDo.DO = *(o.oracleInstanceDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *oracleInstance) updateTableName(table string) *oracleInstance {
	o.ALL = field.NewAsterisk(table)
	o.OracleInstanceID = field.NewString(table, "oracle_instance_id")
	o.ServerID = field.NewString(table, "server_id")
	o.CreateTime = field.NewTime(table, "create_time")
	o.ModifyTime = field.NewTime(table, "modify_time")
	o.Comments = field.NewString(table, "comments")
	o.DbUser = field.NewString(table, "db_user")
	o.DbPwd = field.NewString(table, "db_pwd")
	o.Sid = field.NewString(table, "sid")
	o.ServerName = field.NewString(table, "server_name")
	o.OracleVersion = field.NewString(table, "oracle_version")
	o.SqlAdminRoleID = field.NewString(table, "sql_admin_role_id")
	o.DbPwdBackup = field.NewString(table, "db_pwd_backup")
	o.Dbkey = field.NewString(table, "dbkey")

	o.fillFieldMap()

	return o
}

func (o *oracleInstance) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *oracleInstance) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 13)
	o.fieldMap["oracle_instance_id"] = o.OracleInstanceID
	o.fieldMap["server_id"] = o.ServerID
	o.fieldMap["create_time"] = o.CreateTime
	o.fieldMap["modify_time"] = o.ModifyTime
	o.fieldMap["comments"] = o.Comments
	o.fieldMap["db_user"] = o.DbUser
	o.fieldMap["db_pwd"] = o.DbPwd
	o.fieldMap["sid"] = o.Sid
	o.fieldMap["server_name"] = o.ServerName
	o.fieldMap["oracle_version"] = o.OracleVersion
	o.fieldMap["sql_admin_role_id"] = o.SqlAdminRoleID
	o.fieldMap["db_pwd_backup"] = o.DbPwdBackup
	o.fieldMap["dbkey"] = o.Dbkey
}

func (o oracleInstance) clone(db *gorm.DB) oracleInstance {
	o.oracleInstanceDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o oracleInstance) replaceDB(db *gorm.DB) oracleInstance {
	o.oracleInstanceDo.ReplaceDB(db)
	return o
}

type oracleInstanceDo struct{ gen.DO }

type IOracleInstanceDo interface {
	gen.SubQuery
	Debug() IOracleInstanceDo
	WithContext(ctx context.Context) IOracleInstanceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOracleInstanceDo
	WriteDB() IOracleInstanceDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOracleInstanceDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOracleInstanceDo
	Not(conds ...gen.Condition) IOracleInstanceDo
	Or(conds ...gen.Condition) IOracleInstanceDo
	Select(conds ...field.Expr) IOracleInstanceDo
	Where(conds ...gen.Condition) IOracleInstanceDo
	Order(conds ...field.Expr) IOracleInstanceDo
	Distinct(cols ...field.Expr) IOracleInstanceDo
	Omit(cols ...field.Expr) IOracleInstanceDo
	Join(table schema.Tabler, on ...field.Expr) IOracleInstanceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOracleInstanceDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOracleInstanceDo
	Group(cols ...field.Expr) IOracleInstanceDo
	Having(conds ...gen.Condition) IOracleInstanceDo
	Limit(limit int) IOracleInstanceDo
	Offset(offset int) IOracleInstanceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOracleInstanceDo
	Unscoped() IOracleInstanceDo
	Create(values ...*model.OracleInstance) error
	CreateInBatches(values []*model.OracleInstance, batchSize int) error
	Save(values ...*model.OracleInstance) error
	First() (*model.OracleInstance, error)
	Take() (*model.OracleInstance, error)
	Last() (*model.OracleInstance, error)
	Find() ([]*model.OracleInstance, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OracleInstance, err error)
	FindInBatches(result *[]*model.OracleInstance, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OracleInstance) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOracleInstanceDo
	Assign(attrs ...field.AssignExpr) IOracleInstanceDo
	Joins(fields ...field.RelationField) IOracleInstanceDo
	Preload(fields ...field.RelationField) IOracleInstanceDo
	FirstOrInit() (*model.OracleInstance, error)
	FirstOrCreate() (*model.OracleInstance, error)
	FindByPage(offset int, limit int) (result []*model.OracleInstance, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOracleInstanceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o oracleInstanceDo) Debug() IOracleInstanceDo {
	return o.withDO(o.DO.Debug())
}

func (o oracleInstanceDo) WithContext(ctx context.Context) IOracleInstanceDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o oracleInstanceDo) ReadDB() IOracleInstanceDo {
	return o.Clauses(dbresolver.Read)
}

func (o oracleInstanceDo) WriteDB() IOracleInstanceDo {
	return o.Clauses(dbresolver.Write)
}

func (o oracleInstanceDo) Session(config *gorm.Session) IOracleInstanceDo {
	return o.withDO(o.DO.Session(config))
}

func (o oracleInstanceDo) Clauses(conds ...clause.Expression) IOracleInstanceDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o oracleInstanceDo) Returning(value interface{}, columns ...string) IOracleInstanceDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o oracleInstanceDo) Not(conds ...gen.Condition) IOracleInstanceDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o oracleInstanceDo) Or(conds ...gen.Condition) IOracleInstanceDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o oracleInstanceDo) Select(conds ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o oracleInstanceDo) Where(conds ...gen.Condition) IOracleInstanceDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o oracleInstanceDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IOracleInstanceDo {
	return o.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (o oracleInstanceDo) Order(conds ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o oracleInstanceDo) Distinct(cols ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o oracleInstanceDo) Omit(cols ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o oracleInstanceDo) Join(table schema.Tabler, on ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o oracleInstanceDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o oracleInstanceDo) RightJoin(table schema.Tabler, on ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o oracleInstanceDo) Group(cols ...field.Expr) IOracleInstanceDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o oracleInstanceDo) Having(conds ...gen.Condition) IOracleInstanceDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o oracleInstanceDo) Limit(limit int) IOracleInstanceDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o oracleInstanceDo) Offset(offset int) IOracleInstanceDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o oracleInstanceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOracleInstanceDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o oracleInstanceDo) Unscoped() IOracleInstanceDo {
	return o.withDO(o.DO.Unscoped())
}

func (o oracleInstanceDo) Create(values ...*model.OracleInstance) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o oracleInstanceDo) CreateInBatches(values []*model.OracleInstance, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o oracleInstanceDo) Save(values ...*model.OracleInstance) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o oracleInstanceDo) First() (*model.OracleInstance, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OracleInstance), nil
	}
}

func (o oracleInstanceDo) Take() (*model.OracleInstance, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OracleInstance), nil
	}
}

func (o oracleInstanceDo) Last() (*model.OracleInstance, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OracleInstance), nil
	}
}

func (o oracleInstanceDo) Find() ([]*model.OracleInstance, error) {
	result, err := o.DO.Find()
	return result.([]*model.OracleInstance), err
}

func (o oracleInstanceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OracleInstance, err error) {
	buf := make([]*model.OracleInstance, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o oracleInstanceDo) FindInBatches(result *[]*model.OracleInstance, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o oracleInstanceDo) Attrs(attrs ...field.AssignExpr) IOracleInstanceDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o oracleInstanceDo) Assign(attrs ...field.AssignExpr) IOracleInstanceDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o oracleInstanceDo) Joins(fields ...field.RelationField) IOracleInstanceDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o oracleInstanceDo) Preload(fields ...field.RelationField) IOracleInstanceDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o oracleInstanceDo) FirstOrInit() (*model.OracleInstance, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OracleInstance), nil
	}
}

func (o oracleInstanceDo) FirstOrCreate() (*model.OracleInstance, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OracleInstance), nil
	}
}

func (o oracleInstanceDo) FindByPage(offset int, limit int) (result []*model.OracleInstance, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o oracleInstanceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o oracleInstanceDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o oracleInstanceDo) Delete(models ...*model.OracleInstance) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *oracleInstanceDo) withDO(do gen.Dao) *oracleInstanceDo {
	o.DO = *do.(*gen.DO)
	return o
}
