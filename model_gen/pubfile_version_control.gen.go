// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newPubfileVersionControl(db *gorm.DB, opts ...gen.DOOption) pubfileVersionControl {
	_pubfileVersionControl := pubfileVersionControl{}

	_pubfileVersionControl.pubfileVersionControlDo.UseDB(db, opts...)
	_pubfileVersionControl.pubfileVersionControlDo.UseModel(&model.PubfileVersionControl{})

	tableName := _pubfileVersionControl.pubfileVersionControlDo.TableName()
	_pubfileVersionControl.ALL = field.NewAsterisk(tableName)
	_pubfileVersionControl.PubfileID = field.NewString(tableName, "pubfile_id")
	_pubfileVersionControl.FileName = field.NewString(tableName, "file_name")
	_pubfileVersionControl.FileDepPath = field.NewString(tableName, "file_dep_path")
	_pubfileVersionControl.FileVersion = field.NewInt32(tableName, "file_version")
	_pubfileVersionControl.AddTime = field.NewTime(tableName, "add_time")
	_pubfileVersionControl.AddUser = field.NewString(tableName, "add_user")
	_pubfileVersionControl.FileContent = field.NewBytes(tableName, "file_content")
	_pubfileVersionControl.PubfileType = field.NewString(tableName, "pubfile_type")
	_pubfileVersionControl.ApproveStatus = field.NewString(tableName, "approve_status")
	_pubfileVersionControl.ApproveTime = field.NewTime(tableName, "approve_time")
	_pubfileVersionControl.ApproveUser = field.NewString(tableName, "approve_user")
	_pubfileVersionControl.Note = field.NewString(tableName, "note")

	_pubfileVersionControl.fillFieldMap()

	return _pubfileVersionControl
}

type pubfileVersionControl struct {
	pubfileVersionControlDo

	ALL           field.Asterisk
	PubfileID     field.String // ID
	FileName      field.String // 文件名
	FileDepPath   field.String // 文件部署相对路径
	FileVersion   field.Int32  // 文件版本，默认数值往上累加
	AddTime       field.Time   // 添加时间
	AddUser       field.String // 添加用户
	FileContent   field.Bytes  // 文件内容不大于15M
	PubfileType   field.String // 文件发布类型（1、模板  2、报表）
	ApproveStatus field.String // 审核状态（1、已申请  2、已审核）
	ApproveTime   field.Time   // 审核时间
	ApproveUser   field.String // 审核人
	Note          field.String // 备注

	fieldMap map[string]field.Expr
}

func (p pubfileVersionControl) Table(newTableName string) *pubfileVersionControl {
	p.pubfileVersionControlDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p pubfileVersionControl) As(alias string) *pubfileVersionControl {
	p.pubfileVersionControlDo.DO = *(p.pubfileVersionControlDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *pubfileVersionControl) updateTableName(table string) *pubfileVersionControl {
	p.ALL = field.NewAsterisk(table)
	p.PubfileID = field.NewString(table, "pubfile_id")
	p.FileName = field.NewString(table, "file_name")
	p.FileDepPath = field.NewString(table, "file_dep_path")
	p.FileVersion = field.NewInt32(table, "file_version")
	p.AddTime = field.NewTime(table, "add_time")
	p.AddUser = field.NewString(table, "add_user")
	p.FileContent = field.NewBytes(table, "file_content")
	p.PubfileType = field.NewString(table, "pubfile_type")
	p.ApproveStatus = field.NewString(table, "approve_status")
	p.ApproveTime = field.NewTime(table, "approve_time")
	p.ApproveUser = field.NewString(table, "approve_user")
	p.Note = field.NewString(table, "note")

	p.fillFieldMap()

	return p
}

func (p *pubfileVersionControl) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *pubfileVersionControl) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 12)
	p.fieldMap["pubfile_id"] = p.PubfileID
	p.fieldMap["file_name"] = p.FileName
	p.fieldMap["file_dep_path"] = p.FileDepPath
	p.fieldMap["file_version"] = p.FileVersion
	p.fieldMap["add_time"] = p.AddTime
	p.fieldMap["add_user"] = p.AddUser
	p.fieldMap["file_content"] = p.FileContent
	p.fieldMap["pubfile_type"] = p.PubfileType
	p.fieldMap["approve_status"] = p.ApproveStatus
	p.fieldMap["approve_time"] = p.ApproveTime
	p.fieldMap["approve_user"] = p.ApproveUser
	p.fieldMap["note"] = p.Note
}

func (p pubfileVersionControl) clone(db *gorm.DB) pubfileVersionControl {
	p.pubfileVersionControlDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p pubfileVersionControl) replaceDB(db *gorm.DB) pubfileVersionControl {
	p.pubfileVersionControlDo.ReplaceDB(db)
	return p
}

type pubfileVersionControlDo struct{ gen.DO }

type IPubfileVersionControlDo interface {
	gen.SubQuery
	Debug() IPubfileVersionControlDo
	WithContext(ctx context.Context) IPubfileVersionControlDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPubfileVersionControlDo
	WriteDB() IPubfileVersionControlDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPubfileVersionControlDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPubfileVersionControlDo
	Not(conds ...gen.Condition) IPubfileVersionControlDo
	Or(conds ...gen.Condition) IPubfileVersionControlDo
	Select(conds ...field.Expr) IPubfileVersionControlDo
	Where(conds ...gen.Condition) IPubfileVersionControlDo
	Order(conds ...field.Expr) IPubfileVersionControlDo
	Distinct(cols ...field.Expr) IPubfileVersionControlDo
	Omit(cols ...field.Expr) IPubfileVersionControlDo
	Join(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo
	Group(cols ...field.Expr) IPubfileVersionControlDo
	Having(conds ...gen.Condition) IPubfileVersionControlDo
	Limit(limit int) IPubfileVersionControlDo
	Offset(offset int) IPubfileVersionControlDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPubfileVersionControlDo
	Unscoped() IPubfileVersionControlDo
	Create(values ...*model.PubfileVersionControl) error
	CreateInBatches(values []*model.PubfileVersionControl, batchSize int) error
	Save(values ...*model.PubfileVersionControl) error
	First() (*model.PubfileVersionControl, error)
	Take() (*model.PubfileVersionControl, error)
	Last() (*model.PubfileVersionControl, error)
	Find() ([]*model.PubfileVersionControl, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PubfileVersionControl, err error)
	FindInBatches(result *[]*model.PubfileVersionControl, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PubfileVersionControl) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPubfileVersionControlDo
	Assign(attrs ...field.AssignExpr) IPubfileVersionControlDo
	Joins(fields ...field.RelationField) IPubfileVersionControlDo
	Preload(fields ...field.RelationField) IPubfileVersionControlDo
	FirstOrInit() (*model.PubfileVersionControl, error)
	FirstOrCreate() (*model.PubfileVersionControl, error)
	FindByPage(offset int, limit int) (result []*model.PubfileVersionControl, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPubfileVersionControlDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p pubfileVersionControlDo) Debug() IPubfileVersionControlDo {
	return p.withDO(p.DO.Debug())
}

func (p pubfileVersionControlDo) WithContext(ctx context.Context) IPubfileVersionControlDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p pubfileVersionControlDo) ReadDB() IPubfileVersionControlDo {
	return p.Clauses(dbresolver.Read)
}

func (p pubfileVersionControlDo) WriteDB() IPubfileVersionControlDo {
	return p.Clauses(dbresolver.Write)
}

func (p pubfileVersionControlDo) Session(config *gorm.Session) IPubfileVersionControlDo {
	return p.withDO(p.DO.Session(config))
}

func (p pubfileVersionControlDo) Clauses(conds ...clause.Expression) IPubfileVersionControlDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p pubfileVersionControlDo) Returning(value interface{}, columns ...string) IPubfileVersionControlDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p pubfileVersionControlDo) Not(conds ...gen.Condition) IPubfileVersionControlDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p pubfileVersionControlDo) Or(conds ...gen.Condition) IPubfileVersionControlDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p pubfileVersionControlDo) Select(conds ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p pubfileVersionControlDo) Where(conds ...gen.Condition) IPubfileVersionControlDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p pubfileVersionControlDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IPubfileVersionControlDo {
	return p.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (p pubfileVersionControlDo) Order(conds ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p pubfileVersionControlDo) Distinct(cols ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p pubfileVersionControlDo) Omit(cols ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p pubfileVersionControlDo) Join(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p pubfileVersionControlDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p pubfileVersionControlDo) RightJoin(table schema.Tabler, on ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p pubfileVersionControlDo) Group(cols ...field.Expr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p pubfileVersionControlDo) Having(conds ...gen.Condition) IPubfileVersionControlDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p pubfileVersionControlDo) Limit(limit int) IPubfileVersionControlDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p pubfileVersionControlDo) Offset(offset int) IPubfileVersionControlDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p pubfileVersionControlDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPubfileVersionControlDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p pubfileVersionControlDo) Unscoped() IPubfileVersionControlDo {
	return p.withDO(p.DO.Unscoped())
}

func (p pubfileVersionControlDo) Create(values ...*model.PubfileVersionControl) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p pubfileVersionControlDo) CreateInBatches(values []*model.PubfileVersionControl, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p pubfileVersionControlDo) Save(values ...*model.PubfileVersionControl) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p pubfileVersionControlDo) First() (*model.PubfileVersionControl, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PubfileVersionControl), nil
	}
}

func (p pubfileVersionControlDo) Take() (*model.PubfileVersionControl, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PubfileVersionControl), nil
	}
}

func (p pubfileVersionControlDo) Last() (*model.PubfileVersionControl, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PubfileVersionControl), nil
	}
}

func (p pubfileVersionControlDo) Find() ([]*model.PubfileVersionControl, error) {
	result, err := p.DO.Find()
	return result.([]*model.PubfileVersionControl), err
}

func (p pubfileVersionControlDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PubfileVersionControl, err error) {
	buf := make([]*model.PubfileVersionControl, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p pubfileVersionControlDo) FindInBatches(result *[]*model.PubfileVersionControl, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p pubfileVersionControlDo) Attrs(attrs ...field.AssignExpr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p pubfileVersionControlDo) Assign(attrs ...field.AssignExpr) IPubfileVersionControlDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p pubfileVersionControlDo) Joins(fields ...field.RelationField) IPubfileVersionControlDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p pubfileVersionControlDo) Preload(fields ...field.RelationField) IPubfileVersionControlDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p pubfileVersionControlDo) FirstOrInit() (*model.PubfileVersionControl, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PubfileVersionControl), nil
	}
}

func (p pubfileVersionControlDo) FirstOrCreate() (*model.PubfileVersionControl, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PubfileVersionControl), nil
	}
}

func (p pubfileVersionControlDo) FindByPage(offset int, limit int) (result []*model.PubfileVersionControl, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p pubfileVersionControlDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p pubfileVersionControlDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p pubfileVersionControlDo) Delete(models ...*model.PubfileVersionControl) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *pubfileVersionControlDo) withDO(do gen.Dao) *pubfileVersionControlDo {
	p.DO = *do.(*gen.DO)
	return p
}
