// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newPublishReqCopy(db *gorm.DB, opts ...gen.DOOption) publishReqCopy {
	_publishReqCopy := publishReqCopy{}

	_publishReqCopy.publishReqCopyDo.UseDB(db, opts...)
	_publishReqCopy.publishReqCopyDo.UseModel(&model.PublishReqCopy{})

	tableName := _publishReqCopy.publishReqCopyDo.TableName()
	_publishReqCopy.ALL = field.NewAsterisk(tableName)
	_publishReqCopy.ReqID = field.NewInt32(tableName, "req_id")
	_publishReqCopy.ReqName = field.NewString(tableName, "req_name")
	_publishReqCopy.DevUser = field.NewString(tableName, "dev_user")
	_publishReqCopy.TestUser = field.NewString(tableName, "test_user")
	_publishReqCopy.ScriptUser = field.NewString(tableName, "script_user")
	_publishReqCopy.ReqTime = field.NewTime(tableName, "req_time")
	_publishReqCopy.ReqNotes = field.NewString(tableName, "req_notes")
	_publishReqCopy.CheckFlag = field.NewInt32(tableName, "check_flag")
	_publishReqCopy.DbscriptEventID = field.NewString(tableName, "dbscript_event_id")
	_publishReqCopy.IssueInfos = field.NewString(tableName, "issue_infos")
	_publishReqCopy.FlagDel = field.NewString(tableName, "flag_del")
	_publishReqCopy.PublishVersion = field.NewString(tableName, "publish_version")
	_publishReqCopy.LastDeployTime = field.NewTime(tableName, "last_deploy_time")
	_publishReqCopy.LastRollbackTime = field.NewTime(tableName, "last_rollback_time")
	_publishReqCopy.PrepareDeployTime = field.NewTime(tableName, "prepare_deploy_time")
	_publishReqCopy.ReqSummary = field.NewString(tableName, "req_summary")
	_publishReqCopy.ReqStatu = field.NewInt32(tableName, "req_statu")
	_publishReqCopy.ProTeamID = field.NewString(tableName, "pro_team_id")
	_publishReqCopy.SysProjectID = field.NewString(tableName, "sys_project_id")
	_publishReqCopy.Testreport = field.NewString(tableName, "testreport")
	_publishReqCopy.Rank = field.NewString(tableName, "rank")
	_publishReqCopy.BuiltInTest = field.NewString(tableName, "built_in_test")
	_publishReqCopy.BuildInTestUser = field.NewString(tableName, "build_in_test_user")
	_publishReqCopy.CreateTime = field.NewTime(tableName, "create_time")
	_publishReqCopy.ModifyTime = field.NewTime(tableName, "modify_time")
	_publishReqCopy.Comments = field.NewString(tableName, "comments")
	_publishReqCopy.DeployTime = field.NewTime(tableName, "deploy_time")

	_publishReqCopy.fillFieldMap()

	return _publishReqCopy
}

type publishReqCopy struct {
	publishReqCopyDo

	ALL               field.Asterisk
	ReqID             field.Int32 // 确认单申请ID
	ReqName           field.String
	DevUser           field.String
	TestUser          field.String
	ScriptUser        field.String
	ReqTime           field.Time
	ReqNotes          field.String
	CheckFlag         field.Int32
	DbscriptEventID   field.String
	IssueInfos        field.String
	FlagDel           field.String
	PublishVersion    field.String
	LastDeployTime    field.Time
	LastRollbackTime  field.Time
	PrepareDeployTime field.Time
	ReqSummary        field.String // 升级单概述
	ReqStatu          field.Int32  // 0 已申请 1 开始测试 2测试通过 3 测试未通过 4已部署 5部署失败
	ProTeamID         field.String // 升级单所属项目
	SysProjectID      field.String
	Testreport        field.String // 测试报告HTML文本存储
	/*
		优秀：测试打回0次 良好：测试打回1次 中等：测试打回2次 差：测试打回3次或以上

		1 -1星 差
		2 -2星 中等
		3 -3星 良好
		4 -4星 优秀
	*/
	Rank field.String
	/*
		研发部内部测试流程是否开启
		0、不开启
		1、开启
	*/
	BuiltInTest     field.String
	BuildInTestUser field.String // 内部测试负责人
	CreateTime      field.Time   // 记录创建时间（数据库自动写入）
	ModifyTime      field.Time   // 记录修改时间（数据库自动写入）
	Comments        field.String // 备注说明
	DeployTime      field.Time   // 升级单在点击部署时记录升级单部署时间到数据库，虽然可能不是确切的时间（因为有可能有回退或者有部署失败）但是基本上可以作为参考实际部署时间；

	fieldMap map[string]field.Expr
}

func (p publishReqCopy) Table(newTableName string) *publishReqCopy {
	p.publishReqCopyDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p publishReqCopy) As(alias string) *publishReqCopy {
	p.publishReqCopyDo.DO = *(p.publishReqCopyDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *publishReqCopy) updateTableName(table string) *publishReqCopy {
	p.ALL = field.NewAsterisk(table)
	p.ReqID = field.NewInt32(table, "req_id")
	p.ReqName = field.NewString(table, "req_name")
	p.DevUser = field.NewString(table, "dev_user")
	p.TestUser = field.NewString(table, "test_user")
	p.ScriptUser = field.NewString(table, "script_user")
	p.ReqTime = field.NewTime(table, "req_time")
	p.ReqNotes = field.NewString(table, "req_notes")
	p.CheckFlag = field.NewInt32(table, "check_flag")
	p.DbscriptEventID = field.NewString(table, "dbscript_event_id")
	p.IssueInfos = field.NewString(table, "issue_infos")
	p.FlagDel = field.NewString(table, "flag_del")
	p.PublishVersion = field.NewString(table, "publish_version")
	p.LastDeployTime = field.NewTime(table, "last_deploy_time")
	p.LastRollbackTime = field.NewTime(table, "last_rollback_time")
	p.PrepareDeployTime = field.NewTime(table, "prepare_deploy_time")
	p.ReqSummary = field.NewString(table, "req_summary")
	p.ReqStatu = field.NewInt32(table, "req_statu")
	p.ProTeamID = field.NewString(table, "pro_team_id")
	p.SysProjectID = field.NewString(table, "sys_project_id")
	p.Testreport = field.NewString(table, "testreport")
	p.Rank = field.NewString(table, "rank")
	p.BuiltInTest = field.NewString(table, "built_in_test")
	p.BuildInTestUser = field.NewString(table, "build_in_test_user")
	p.CreateTime = field.NewTime(table, "create_time")
	p.ModifyTime = field.NewTime(table, "modify_time")
	p.Comments = field.NewString(table, "comments")
	p.DeployTime = field.NewTime(table, "deploy_time")

	p.fillFieldMap()

	return p
}

func (p *publishReqCopy) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *publishReqCopy) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 27)
	p.fieldMap["req_id"] = p.ReqID
	p.fieldMap["req_name"] = p.ReqName
	p.fieldMap["dev_user"] = p.DevUser
	p.fieldMap["test_user"] = p.TestUser
	p.fieldMap["script_user"] = p.ScriptUser
	p.fieldMap["req_time"] = p.ReqTime
	p.fieldMap["req_notes"] = p.ReqNotes
	p.fieldMap["check_flag"] = p.CheckFlag
	p.fieldMap["dbscript_event_id"] = p.DbscriptEventID
	p.fieldMap["issue_infos"] = p.IssueInfos
	p.fieldMap["flag_del"] = p.FlagDel
	p.fieldMap["publish_version"] = p.PublishVersion
	p.fieldMap["last_deploy_time"] = p.LastDeployTime
	p.fieldMap["last_rollback_time"] = p.LastRollbackTime
	p.fieldMap["prepare_deploy_time"] = p.PrepareDeployTime
	p.fieldMap["req_summary"] = p.ReqSummary
	p.fieldMap["req_statu"] = p.ReqStatu
	p.fieldMap["pro_team_id"] = p.ProTeamID
	p.fieldMap["sys_project_id"] = p.SysProjectID
	p.fieldMap["testreport"] = p.Testreport
	p.fieldMap["rank"] = p.Rank
	p.fieldMap["built_in_test"] = p.BuiltInTest
	p.fieldMap["build_in_test_user"] = p.BuildInTestUser
	p.fieldMap["create_time"] = p.CreateTime
	p.fieldMap["modify_time"] = p.ModifyTime
	p.fieldMap["comments"] = p.Comments
	p.fieldMap["deploy_time"] = p.DeployTime
}

func (p publishReqCopy) clone(db *gorm.DB) publishReqCopy {
	p.publishReqCopyDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p publishReqCopy) replaceDB(db *gorm.DB) publishReqCopy {
	p.publishReqCopyDo.ReplaceDB(db)
	return p
}

type publishReqCopyDo struct{ gen.DO }

type IPublishReqCopyDo interface {
	gen.SubQuery
	Debug() IPublishReqCopyDo
	WithContext(ctx context.Context) IPublishReqCopyDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPublishReqCopyDo
	WriteDB() IPublishReqCopyDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPublishReqCopyDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPublishReqCopyDo
	Not(conds ...gen.Condition) IPublishReqCopyDo
	Or(conds ...gen.Condition) IPublishReqCopyDo
	Select(conds ...field.Expr) IPublishReqCopyDo
	Where(conds ...gen.Condition) IPublishReqCopyDo
	Order(conds ...field.Expr) IPublishReqCopyDo
	Distinct(cols ...field.Expr) IPublishReqCopyDo
	Omit(cols ...field.Expr) IPublishReqCopyDo
	Join(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo
	Group(cols ...field.Expr) IPublishReqCopyDo
	Having(conds ...gen.Condition) IPublishReqCopyDo
	Limit(limit int) IPublishReqCopyDo
	Offset(offset int) IPublishReqCopyDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPublishReqCopyDo
	Unscoped() IPublishReqCopyDo
	Create(values ...*model.PublishReqCopy) error
	CreateInBatches(values []*model.PublishReqCopy, batchSize int) error
	Save(values ...*model.PublishReqCopy) error
	First() (*model.PublishReqCopy, error)
	Take() (*model.PublishReqCopy, error)
	Last() (*model.PublishReqCopy, error)
	Find() ([]*model.PublishReqCopy, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PublishReqCopy, err error)
	FindInBatches(result *[]*model.PublishReqCopy, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PublishReqCopy) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPublishReqCopyDo
	Assign(attrs ...field.AssignExpr) IPublishReqCopyDo
	Joins(fields ...field.RelationField) IPublishReqCopyDo
	Preload(fields ...field.RelationField) IPublishReqCopyDo
	FirstOrInit() (*model.PublishReqCopy, error)
	FirstOrCreate() (*model.PublishReqCopy, error)
	FindByPage(offset int, limit int) (result []*model.PublishReqCopy, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPublishReqCopyDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p publishReqCopyDo) Debug() IPublishReqCopyDo {
	return p.withDO(p.DO.Debug())
}

func (p publishReqCopyDo) WithContext(ctx context.Context) IPublishReqCopyDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p publishReqCopyDo) ReadDB() IPublishReqCopyDo {
	return p.Clauses(dbresolver.Read)
}

func (p publishReqCopyDo) WriteDB() IPublishReqCopyDo {
	return p.Clauses(dbresolver.Write)
}

func (p publishReqCopyDo) Session(config *gorm.Session) IPublishReqCopyDo {
	return p.withDO(p.DO.Session(config))
}

func (p publishReqCopyDo) Clauses(conds ...clause.Expression) IPublishReqCopyDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p publishReqCopyDo) Returning(value interface{}, columns ...string) IPublishReqCopyDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p publishReqCopyDo) Not(conds ...gen.Condition) IPublishReqCopyDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p publishReqCopyDo) Or(conds ...gen.Condition) IPublishReqCopyDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p publishReqCopyDo) Select(conds ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p publishReqCopyDo) Where(conds ...gen.Condition) IPublishReqCopyDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p publishReqCopyDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IPublishReqCopyDo {
	return p.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (p publishReqCopyDo) Order(conds ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p publishReqCopyDo) Distinct(cols ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p publishReqCopyDo) Omit(cols ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p publishReqCopyDo) Join(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p publishReqCopyDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p publishReqCopyDo) RightJoin(table schema.Tabler, on ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p publishReqCopyDo) Group(cols ...field.Expr) IPublishReqCopyDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p publishReqCopyDo) Having(conds ...gen.Condition) IPublishReqCopyDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p publishReqCopyDo) Limit(limit int) IPublishReqCopyDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p publishReqCopyDo) Offset(offset int) IPublishReqCopyDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p publishReqCopyDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPublishReqCopyDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p publishReqCopyDo) Unscoped() IPublishReqCopyDo {
	return p.withDO(p.DO.Unscoped())
}

func (p publishReqCopyDo) Create(values ...*model.PublishReqCopy) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p publishReqCopyDo) CreateInBatches(values []*model.PublishReqCopy, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p publishReqCopyDo) Save(values ...*model.PublishReqCopy) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p publishReqCopyDo) First() (*model.PublishReqCopy, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PublishReqCopy), nil
	}
}

func (p publishReqCopyDo) Take() (*model.PublishReqCopy, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PublishReqCopy), nil
	}
}

func (p publishReqCopyDo) Last() (*model.PublishReqCopy, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PublishReqCopy), nil
	}
}

func (p publishReqCopyDo) Find() ([]*model.PublishReqCopy, error) {
	result, err := p.DO.Find()
	return result.([]*model.PublishReqCopy), err
}

func (p publishReqCopyDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PublishReqCopy, err error) {
	buf := make([]*model.PublishReqCopy, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p publishReqCopyDo) FindInBatches(result *[]*model.PublishReqCopy, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p publishReqCopyDo) Attrs(attrs ...field.AssignExpr) IPublishReqCopyDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p publishReqCopyDo) Assign(attrs ...field.AssignExpr) IPublishReqCopyDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p publishReqCopyDo) Joins(fields ...field.RelationField) IPublishReqCopyDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p publishReqCopyDo) Preload(fields ...field.RelationField) IPublishReqCopyDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p publishReqCopyDo) FirstOrInit() (*model.PublishReqCopy, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PublishReqCopy), nil
	}
}

func (p publishReqCopyDo) FirstOrCreate() (*model.PublishReqCopy, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PublishReqCopy), nil
	}
}

func (p publishReqCopyDo) FindByPage(offset int, limit int) (result []*model.PublishReqCopy, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p publishReqCopyDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p publishReqCopyDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p publishReqCopyDo) Delete(models ...*model.PublishReqCopy) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *publishReqCopyDo) withDO(do gen.Dao) *publishReqCopyDo {
	p.DO = *do.(*gen.DO)
	return p
}
