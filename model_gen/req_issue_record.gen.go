// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newReqIssueRecord(db *gorm.DB, opts ...gen.DOOption) reqIssueRecord {
	_reqIssueRecord := reqIssueRecord{}

	_reqIssueRecord.reqIssueRecordDo.UseDB(db, opts...)
	_reqIssueRecord.reqIssueRecordDo.UseModel(&model.ReqIssueRecord{})

	tableName := _reqIssueRecord.reqIssueRecordDo.TableName()
	_reqIssueRecord.ALL = field.NewAsterisk(tableName)
	_reqIssueRecord.ReqIssueRecordID = field.NewString(tableName, "req_issue_record_id")
	_reqIssueRecord.Issues = field.NewString(tableName, "issues")
	_reqIssueRecord.ServerEnvID = field.NewString(tableName, "server_env_id")
	_reqIssueRecord.Description = field.NewString(tableName, "description")
	_reqIssueRecord.Comment = field.NewString(tableName, "comment")
	_reqIssueRecord.PublishVersion = field.NewString(tableName, "publish_version")
	_reqIssueRecord.SubmitUser = field.NewString(tableName, "submit_user")
	_reqIssueRecord.SubmitTime = field.NewString(tableName, "submit_time")
	_reqIssueRecord.IsBug = field.NewString(tableName, "is_bug")
	_reqIssueRecord.ProblemType = field.NewString(tableName, "problem_type")
	_reqIssueRecord.ResolveStatus = field.NewString(tableName, "resolve_status")
	_reqIssueRecord.ResolveUser = field.NewString(tableName, "resolve_user")
	_reqIssueRecord.ResolveTime = field.NewString(tableName, "resolve_time")
	_reqIssueRecord.ResolveCount = field.NewInt32(tableName, "resolve_count")
	_reqIssueRecord.AddTime = field.NewString(tableName, "add_time")
	_reqIssueRecord.OpUser = field.NewString(tableName, "op_user")
	_reqIssueRecord.ProblemLevel = field.NewString(tableName, "problem_level")
	_reqIssueRecord.IsEffectVersion = field.NewString(tableName, "is_effect_version")
	_reqIssueRecord.Avoid = field.NewString(tableName, "avoid")
	_reqIssueRecord.TestUser = field.NewString(tableName, "test_user")
	_reqIssueRecord.RelativeIssues = field.NewString(tableName, "relative_issues")
	_reqIssueRecord.RelativeVersion = field.NewString(tableName, "relative_version")
	_reqIssueRecord.RelativeReason = field.NewString(tableName, "relative_reason")
	_reqIssueRecord.ProblemReasons = field.NewString(tableName, "problem_reasons")

	_reqIssueRecord.fillFieldMap()

	return _reqIssueRecord
}

type reqIssueRecord struct {
	reqIssueRecordDo

	ALL              field.Asterisk
	ReqIssueRecordID field.String
	Issues           field.String // 以逗号分割
	ServerEnvID      field.String
	Description      field.String // 问题描述
	Comment          field.String // 备注
	PublishVersion   field.String // 版本号
	SubmitUser       field.String
	SubmitTime       field.String
	IsBug            field.String
	ProblemType      field.String
	ResolveStatus    field.String
	ResolveUser      field.String
	ResolveTime      field.String
	ResolveCount     field.Int32
	AddTime          field.String
	OpUser           field.String
	ProblemLevel     field.String
	IsEffectVersion  field.String
	Avoid            field.String
	TestUser         field.String
	RelativeIssues   field.String
	RelativeVersion  field.String
	RelativeReason   field.String
	ProblemReasons   field.String

	fieldMap map[string]field.Expr
}

func (r reqIssueRecord) Table(newTableName string) *reqIssueRecord {
	r.reqIssueRecordDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r reqIssueRecord) As(alias string) *reqIssueRecord {
	r.reqIssueRecordDo.DO = *(r.reqIssueRecordDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *reqIssueRecord) updateTableName(table string) *reqIssueRecord {
	r.ALL = field.NewAsterisk(table)
	r.ReqIssueRecordID = field.NewString(table, "req_issue_record_id")
	r.Issues = field.NewString(table, "issues")
	r.ServerEnvID = field.NewString(table, "server_env_id")
	r.Description = field.NewString(table, "description")
	r.Comment = field.NewString(table, "comment")
	r.PublishVersion = field.NewString(table, "publish_version")
	r.SubmitUser = field.NewString(table, "submit_user")
	r.SubmitTime = field.NewString(table, "submit_time")
	r.IsBug = field.NewString(table, "is_bug")
	r.ProblemType = field.NewString(table, "problem_type")
	r.ResolveStatus = field.NewString(table, "resolve_status")
	r.ResolveUser = field.NewString(table, "resolve_user")
	r.ResolveTime = field.NewString(table, "resolve_time")
	r.ResolveCount = field.NewInt32(table, "resolve_count")
	r.AddTime = field.NewString(table, "add_time")
	r.OpUser = field.NewString(table, "op_user")
	r.ProblemLevel = field.NewString(table, "problem_level")
	r.IsEffectVersion = field.NewString(table, "is_effect_version")
	r.Avoid = field.NewString(table, "avoid")
	r.TestUser = field.NewString(table, "test_user")
	r.RelativeIssues = field.NewString(table, "relative_issues")
	r.RelativeVersion = field.NewString(table, "relative_version")
	r.RelativeReason = field.NewString(table, "relative_reason")
	r.ProblemReasons = field.NewString(table, "problem_reasons")

	r.fillFieldMap()

	return r
}

func (r *reqIssueRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *reqIssueRecord) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 24)
	r.fieldMap["req_issue_record_id"] = r.ReqIssueRecordID
	r.fieldMap["issues"] = r.Issues
	r.fieldMap["server_env_id"] = r.ServerEnvID
	r.fieldMap["description"] = r.Description
	r.fieldMap["comment"] = r.Comment
	r.fieldMap["publish_version"] = r.PublishVersion
	r.fieldMap["submit_user"] = r.SubmitUser
	r.fieldMap["submit_time"] = r.SubmitTime
	r.fieldMap["is_bug"] = r.IsBug
	r.fieldMap["problem_type"] = r.ProblemType
	r.fieldMap["resolve_status"] = r.ResolveStatus
	r.fieldMap["resolve_user"] = r.ResolveUser
	r.fieldMap["resolve_time"] = r.ResolveTime
	r.fieldMap["resolve_count"] = r.ResolveCount
	r.fieldMap["add_time"] = r.AddTime
	r.fieldMap["op_user"] = r.OpUser
	r.fieldMap["problem_level"] = r.ProblemLevel
	r.fieldMap["is_effect_version"] = r.IsEffectVersion
	r.fieldMap["avoid"] = r.Avoid
	r.fieldMap["test_user"] = r.TestUser
	r.fieldMap["relative_issues"] = r.RelativeIssues
	r.fieldMap["relative_version"] = r.RelativeVersion
	r.fieldMap["relative_reason"] = r.RelativeReason
	r.fieldMap["problem_reasons"] = r.ProblemReasons
}

func (r reqIssueRecord) clone(db *gorm.DB) reqIssueRecord {
	r.reqIssueRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r reqIssueRecord) replaceDB(db *gorm.DB) reqIssueRecord {
	r.reqIssueRecordDo.ReplaceDB(db)
	return r
}

type reqIssueRecordDo struct{ gen.DO }

type IReqIssueRecordDo interface {
	gen.SubQuery
	Debug() IReqIssueRecordDo
	WithContext(ctx context.Context) IReqIssueRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IReqIssueRecordDo
	WriteDB() IReqIssueRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IReqIssueRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IReqIssueRecordDo
	Not(conds ...gen.Condition) IReqIssueRecordDo
	Or(conds ...gen.Condition) IReqIssueRecordDo
	Select(conds ...field.Expr) IReqIssueRecordDo
	Where(conds ...gen.Condition) IReqIssueRecordDo
	Order(conds ...field.Expr) IReqIssueRecordDo
	Distinct(cols ...field.Expr) IReqIssueRecordDo
	Omit(cols ...field.Expr) IReqIssueRecordDo
	Join(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo
	Group(cols ...field.Expr) IReqIssueRecordDo
	Having(conds ...gen.Condition) IReqIssueRecordDo
	Limit(limit int) IReqIssueRecordDo
	Offset(offset int) IReqIssueRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IReqIssueRecordDo
	Unscoped() IReqIssueRecordDo
	Create(values ...*model.ReqIssueRecord) error
	CreateInBatches(values []*model.ReqIssueRecord, batchSize int) error
	Save(values ...*model.ReqIssueRecord) error
	First() (*model.ReqIssueRecord, error)
	Take() (*model.ReqIssueRecord, error)
	Last() (*model.ReqIssueRecord, error)
	Find() ([]*model.ReqIssueRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ReqIssueRecord, err error)
	FindInBatches(result *[]*model.ReqIssueRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ReqIssueRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IReqIssueRecordDo
	Assign(attrs ...field.AssignExpr) IReqIssueRecordDo
	Joins(fields ...field.RelationField) IReqIssueRecordDo
	Preload(fields ...field.RelationField) IReqIssueRecordDo
	FirstOrInit() (*model.ReqIssueRecord, error)
	FirstOrCreate() (*model.ReqIssueRecord, error)
	FindByPage(offset int, limit int) (result []*model.ReqIssueRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IReqIssueRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r reqIssueRecordDo) Debug() IReqIssueRecordDo {
	return r.withDO(r.DO.Debug())
}

func (r reqIssueRecordDo) WithContext(ctx context.Context) IReqIssueRecordDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r reqIssueRecordDo) ReadDB() IReqIssueRecordDo {
	return r.Clauses(dbresolver.Read)
}

func (r reqIssueRecordDo) WriteDB() IReqIssueRecordDo {
	return r.Clauses(dbresolver.Write)
}

func (r reqIssueRecordDo) Session(config *gorm.Session) IReqIssueRecordDo {
	return r.withDO(r.DO.Session(config))
}

func (r reqIssueRecordDo) Clauses(conds ...clause.Expression) IReqIssueRecordDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r reqIssueRecordDo) Returning(value interface{}, columns ...string) IReqIssueRecordDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r reqIssueRecordDo) Not(conds ...gen.Condition) IReqIssueRecordDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r reqIssueRecordDo) Or(conds ...gen.Condition) IReqIssueRecordDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r reqIssueRecordDo) Select(conds ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r reqIssueRecordDo) Where(conds ...gen.Condition) IReqIssueRecordDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r reqIssueRecordDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IReqIssueRecordDo {
	return r.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (r reqIssueRecordDo) Order(conds ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r reqIssueRecordDo) Distinct(cols ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r reqIssueRecordDo) Omit(cols ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r reqIssueRecordDo) Join(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r reqIssueRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r reqIssueRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r reqIssueRecordDo) Group(cols ...field.Expr) IReqIssueRecordDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r reqIssueRecordDo) Having(conds ...gen.Condition) IReqIssueRecordDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r reqIssueRecordDo) Limit(limit int) IReqIssueRecordDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r reqIssueRecordDo) Offset(offset int) IReqIssueRecordDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r reqIssueRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IReqIssueRecordDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r reqIssueRecordDo) Unscoped() IReqIssueRecordDo {
	return r.withDO(r.DO.Unscoped())
}

func (r reqIssueRecordDo) Create(values ...*model.ReqIssueRecord) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r reqIssueRecordDo) CreateInBatches(values []*model.ReqIssueRecord, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r reqIssueRecordDo) Save(values ...*model.ReqIssueRecord) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r reqIssueRecordDo) First() (*model.ReqIssueRecord, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ReqIssueRecord), nil
	}
}

func (r reqIssueRecordDo) Take() (*model.ReqIssueRecord, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ReqIssueRecord), nil
	}
}

func (r reqIssueRecordDo) Last() (*model.ReqIssueRecord, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ReqIssueRecord), nil
	}
}

func (r reqIssueRecordDo) Find() ([]*model.ReqIssueRecord, error) {
	result, err := r.DO.Find()
	return result.([]*model.ReqIssueRecord), err
}

func (r reqIssueRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ReqIssueRecord, err error) {
	buf := make([]*model.ReqIssueRecord, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r reqIssueRecordDo) FindInBatches(result *[]*model.ReqIssueRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r reqIssueRecordDo) Attrs(attrs ...field.AssignExpr) IReqIssueRecordDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r reqIssueRecordDo) Assign(attrs ...field.AssignExpr) IReqIssueRecordDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r reqIssueRecordDo) Joins(fields ...field.RelationField) IReqIssueRecordDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r reqIssueRecordDo) Preload(fields ...field.RelationField) IReqIssueRecordDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r reqIssueRecordDo) FirstOrInit() (*model.ReqIssueRecord, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ReqIssueRecord), nil
	}
}

func (r reqIssueRecordDo) FirstOrCreate() (*model.ReqIssueRecord, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ReqIssueRecord), nil
	}
}

func (r reqIssueRecordDo) FindByPage(offset int, limit int) (result []*model.ReqIssueRecord, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r reqIssueRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r reqIssueRecordDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r reqIssueRecordDo) Delete(models ...*model.ReqIssueRecord) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *reqIssueRecordDo) withDO(do gen.Dao) *reqIssueRecordDo {
	r.DO = *do.(*gen.DO)
	return r
}
