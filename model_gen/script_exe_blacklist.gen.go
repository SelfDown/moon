// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newScriptExeBlacklist(db *gorm.DB, opts ...gen.DOOption) scriptExeBlacklist {
	_scriptExeBlacklist := scriptExeBlacklist{}

	_scriptExeBlacklist.scriptExeBlacklistDo.UseDB(db, opts...)
	_scriptExeBlacklist.scriptExeBlacklistDo.UseModel(&model.ScriptExeBlacklist{})

	tableName := _scriptExeBlacklist.scriptExeBlacklistDo.TableName()
	_scriptExeBlacklist.ALL = field.NewAsterisk(tableName)
	_scriptExeBlacklist.ExeBlacklistID = field.NewString(tableName, "exe_blacklist_id")
	_scriptExeBlacklist.ExeActionName = field.NewString(tableName, "exe_action_name")
	_scriptExeBlacklist.ExeActionType = field.NewString(tableName, "exe_action_type")
	_scriptExeBlacklist.OpUser = field.NewString(tableName, "op_user")
	_scriptExeBlacklist.ExeScript = field.NewString(tableName, "exe_script")
	_scriptExeBlacklist.AddTime = field.NewTime(tableName, "add_time")
	_scriptExeBlacklist.Comments = field.NewString(tableName, "comments")

	_scriptExeBlacklist.fillFieldMap()

	return _scriptExeBlacklist
}

type scriptExeBlacklist struct {
	scriptExeBlacklistDo

	ALL            field.Asterisk
	ExeBlacklistID field.String
	ExeActionName  field.String
	ExeActionType  field.String
	OpUser         field.String
	ExeScript      field.String
	AddTime        field.Time
	Comments       field.String

	fieldMap map[string]field.Expr
}

func (s scriptExeBlacklist) Table(newTableName string) *scriptExeBlacklist {
	s.scriptExeBlacklistDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s scriptExeBlacklist) As(alias string) *scriptExeBlacklist {
	s.scriptExeBlacklistDo.DO = *(s.scriptExeBlacklistDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *scriptExeBlacklist) updateTableName(table string) *scriptExeBlacklist {
	s.ALL = field.NewAsterisk(table)
	s.ExeBlacklistID = field.NewString(table, "exe_blacklist_id")
	s.ExeActionName = field.NewString(table, "exe_action_name")
	s.ExeActionType = field.NewString(table, "exe_action_type")
	s.OpUser = field.NewString(table, "op_user")
	s.ExeScript = field.NewString(table, "exe_script")
	s.AddTime = field.NewTime(table, "add_time")
	s.Comments = field.NewString(table, "comments")

	s.fillFieldMap()

	return s
}

func (s *scriptExeBlacklist) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *scriptExeBlacklist) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 7)
	s.fieldMap["exe_blacklist_id"] = s.ExeBlacklistID
	s.fieldMap["exe_action_name"] = s.ExeActionName
	s.fieldMap["exe_action_type"] = s.ExeActionType
	s.fieldMap["op_user"] = s.OpUser
	s.fieldMap["exe_script"] = s.ExeScript
	s.fieldMap["add_time"] = s.AddTime
	s.fieldMap["comments"] = s.Comments
}

func (s scriptExeBlacklist) clone(db *gorm.DB) scriptExeBlacklist {
	s.scriptExeBlacklistDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s scriptExeBlacklist) replaceDB(db *gorm.DB) scriptExeBlacklist {
	s.scriptExeBlacklistDo.ReplaceDB(db)
	return s
}

type scriptExeBlacklistDo struct{ gen.DO }

type IScriptExeBlacklistDo interface {
	gen.SubQuery
	Debug() IScriptExeBlacklistDo
	WithContext(ctx context.Context) IScriptExeBlacklistDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IScriptExeBlacklistDo
	WriteDB() IScriptExeBlacklistDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IScriptExeBlacklistDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IScriptExeBlacklistDo
	Not(conds ...gen.Condition) IScriptExeBlacklistDo
	Or(conds ...gen.Condition) IScriptExeBlacklistDo
	Select(conds ...field.Expr) IScriptExeBlacklistDo
	Where(conds ...gen.Condition) IScriptExeBlacklistDo
	Order(conds ...field.Expr) IScriptExeBlacklistDo
	Distinct(cols ...field.Expr) IScriptExeBlacklistDo
	Omit(cols ...field.Expr) IScriptExeBlacklistDo
	Join(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo
	RightJoin(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo
	Group(cols ...field.Expr) IScriptExeBlacklistDo
	Having(conds ...gen.Condition) IScriptExeBlacklistDo
	Limit(limit int) IScriptExeBlacklistDo
	Offset(offset int) IScriptExeBlacklistDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IScriptExeBlacklistDo
	Unscoped() IScriptExeBlacklistDo
	Create(values ...*model.ScriptExeBlacklist) error
	CreateInBatches(values []*model.ScriptExeBlacklist, batchSize int) error
	Save(values ...*model.ScriptExeBlacklist) error
	First() (*model.ScriptExeBlacklist, error)
	Take() (*model.ScriptExeBlacklist, error)
	Last() (*model.ScriptExeBlacklist, error)
	Find() ([]*model.ScriptExeBlacklist, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScriptExeBlacklist, err error)
	FindInBatches(result *[]*model.ScriptExeBlacklist, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ScriptExeBlacklist) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IScriptExeBlacklistDo
	Assign(attrs ...field.AssignExpr) IScriptExeBlacklistDo
	Joins(fields ...field.RelationField) IScriptExeBlacklistDo
	Preload(fields ...field.RelationField) IScriptExeBlacklistDo
	FirstOrInit() (*model.ScriptExeBlacklist, error)
	FirstOrCreate() (*model.ScriptExeBlacklist, error)
	FindByPage(offset int, limit int) (result []*model.ScriptExeBlacklist, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IScriptExeBlacklistDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s scriptExeBlacklistDo) Debug() IScriptExeBlacklistDo {
	return s.withDO(s.DO.Debug())
}

func (s scriptExeBlacklistDo) WithContext(ctx context.Context) IScriptExeBlacklistDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s scriptExeBlacklistDo) ReadDB() IScriptExeBlacklistDo {
	return s.Clauses(dbresolver.Read)
}

func (s scriptExeBlacklistDo) WriteDB() IScriptExeBlacklistDo {
	return s.Clauses(dbresolver.Write)
}

func (s scriptExeBlacklistDo) Session(config *gorm.Session) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Session(config))
}

func (s scriptExeBlacklistDo) Clauses(conds ...clause.Expression) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s scriptExeBlacklistDo) Returning(value interface{}, columns ...string) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s scriptExeBlacklistDo) Not(conds ...gen.Condition) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s scriptExeBlacklistDo) Or(conds ...gen.Condition) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s scriptExeBlacklistDo) Select(conds ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s scriptExeBlacklistDo) Where(conds ...gen.Condition) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s scriptExeBlacklistDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IScriptExeBlacklistDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s scriptExeBlacklistDo) Order(conds ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s scriptExeBlacklistDo) Distinct(cols ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s scriptExeBlacklistDo) Omit(cols ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s scriptExeBlacklistDo) Join(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s scriptExeBlacklistDo) LeftJoin(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s scriptExeBlacklistDo) RightJoin(table schema.Tabler, on ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s scriptExeBlacklistDo) Group(cols ...field.Expr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s scriptExeBlacklistDo) Having(conds ...gen.Condition) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s scriptExeBlacklistDo) Limit(limit int) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s scriptExeBlacklistDo) Offset(offset int) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s scriptExeBlacklistDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s scriptExeBlacklistDo) Unscoped() IScriptExeBlacklistDo {
	return s.withDO(s.DO.Unscoped())
}

func (s scriptExeBlacklistDo) Create(values ...*model.ScriptExeBlacklist) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s scriptExeBlacklistDo) CreateInBatches(values []*model.ScriptExeBlacklist, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s scriptExeBlacklistDo) Save(values ...*model.ScriptExeBlacklist) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s scriptExeBlacklistDo) First() (*model.ScriptExeBlacklist, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScriptExeBlacklist), nil
	}
}

func (s scriptExeBlacklistDo) Take() (*model.ScriptExeBlacklist, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScriptExeBlacklist), nil
	}
}

func (s scriptExeBlacklistDo) Last() (*model.ScriptExeBlacklist, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScriptExeBlacklist), nil
	}
}

func (s scriptExeBlacklistDo) Find() ([]*model.ScriptExeBlacklist, error) {
	result, err := s.DO.Find()
	return result.([]*model.ScriptExeBlacklist), err
}

func (s scriptExeBlacklistDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScriptExeBlacklist, err error) {
	buf := make([]*model.ScriptExeBlacklist, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s scriptExeBlacklistDo) FindInBatches(result *[]*model.ScriptExeBlacklist, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s scriptExeBlacklistDo) Attrs(attrs ...field.AssignExpr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s scriptExeBlacklistDo) Assign(attrs ...field.AssignExpr) IScriptExeBlacklistDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s scriptExeBlacklistDo) Joins(fields ...field.RelationField) IScriptExeBlacklistDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s scriptExeBlacklistDo) Preload(fields ...field.RelationField) IScriptExeBlacklistDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s scriptExeBlacklistDo) FirstOrInit() (*model.ScriptExeBlacklist, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScriptExeBlacklist), nil
	}
}

func (s scriptExeBlacklistDo) FirstOrCreate() (*model.ScriptExeBlacklist, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScriptExeBlacklist), nil
	}
}

func (s scriptExeBlacklistDo) FindByPage(offset int, limit int) (result []*model.ScriptExeBlacklist, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s scriptExeBlacklistDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s scriptExeBlacklistDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s scriptExeBlacklistDo) Delete(models ...*model.ScriptExeBlacklist) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *scriptExeBlacklistDo) withDO(do gen.Dao) *scriptExeBlacklistDo {
	s.DO = *do.(*gen.DO)
	return s
}
