// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model_gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"moon/model"
)

func newSysProjects(db *gorm.DB, opts ...gen.DOOption) sysProjects {
	_sysProjects := sysProjects{}

	_sysProjects.sysProjectsDo.UseDB(db, opts...)
	_sysProjects.sysProjectsDo.UseModel(&model.SysProjects{})

	tableName := _sysProjects.sysProjectsDo.TableName()
	_sysProjects.ALL = field.NewAsterisk(tableName)
	_sysProjects.SysProjectID = field.NewString(tableName, "sys_project_id")
	_sysProjects.ProjectName = field.NewString(tableName, "project_name")
	_sysProjects.ProjectCode = field.NewString(tableName, "project_code")
	_sysProjects.ServerIP = field.NewString(tableName, "server_ip")
	_sysProjects.ProjectLeader = field.NewString(tableName, "project_leader")
	_sysProjects.ZabbixServiceID = field.NewInt32(tableName, "zabbix_service_id")
	_sysProjects.WechatID = field.NewInt32(tableName, "wechat_id")
	_sysProjects.ZabbixMaxMaintenanceTime = field.NewInt32(tableName, "zabbix_max_maintenance_time")
	_sysProjects.Notes = field.NewString(tableName, "notes")
	_sysProjects.Jiraspace = field.NewString(tableName, "jiraspace")
	_sysProjects.Selected = field.NewString(tableName, "selected")
	_sysProjects.Site = field.NewString(tableName, "site")
	_sysProjects.GitBranchSql = field.NewString(tableName, "git_branch_sql")
	_sysProjects.PorjectNameSql = field.NewString(tableName, "porject_name_sql")
	_sysProjects.CreateTime = field.NewTime(tableName, "create_time")
	_sysProjects.ModifyTime = field.NewTime(tableName, "modify_time")
	_sysProjects.Comments = field.NewString(tableName, "comments")
	_sysProjects.FlagDel = field.NewString(tableName, "flag_del")
	_sysProjects.OrderID = field.NewInt32(tableName, "order_id")

	_sysProjects.fillFieldMap()

	return _sysProjects
}

type sysProjects struct {
	sysProjectsDo

	ALL                      field.Asterisk
	SysProjectID             field.String
	ProjectName              field.String
	ProjectCode              field.String
	ServerIP                 field.String
	ProjectLeader            field.String
	ZabbixServiceID          field.Int32 // zabbix service id
	WechatID                 field.Int32 // 微信配置id
	ZabbixMaxMaintenanceTime field.Int32 // zabbix 最大维护时间（分钟）
	Notes                    field.String
	Jiraspace                field.String
	Selected                 field.String // 是否被默认选中，True表示这个项目为默认项目点
	Site                     field.String // HTTP访问地址
	GitBranchSql             field.String // 脚本归档所属分支
	PorjectNameSql           field.String // 脚本归档管理关联的【应用服务】，具体记录来自JIRA
	CreateTime               field.Time   // 记录创建时间（数据库自动写入）
	ModifyTime               field.Time   // 记录修改时间（数据库自动写入）
	Comments                 field.String // 备注说明
	FlagDel                  field.String
	OrderID                  field.Int32

	fieldMap map[string]field.Expr
}

func (s sysProjects) Table(newTableName string) *sysProjects {
	s.sysProjectsDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysProjects) As(alias string) *sysProjects {
	s.sysProjectsDo.DO = *(s.sysProjectsDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysProjects) updateTableName(table string) *sysProjects {
	s.ALL = field.NewAsterisk(table)
	s.SysProjectID = field.NewString(table, "sys_project_id")
	s.ProjectName = field.NewString(table, "project_name")
	s.ProjectCode = field.NewString(table, "project_code")
	s.ServerIP = field.NewString(table, "server_ip")
	s.ProjectLeader = field.NewString(table, "project_leader")
	s.ZabbixServiceID = field.NewInt32(table, "zabbix_service_id")
	s.WechatID = field.NewInt32(table, "wechat_id")
	s.ZabbixMaxMaintenanceTime = field.NewInt32(table, "zabbix_max_maintenance_time")
	s.Notes = field.NewString(table, "notes")
	s.Jiraspace = field.NewString(table, "jiraspace")
	s.Selected = field.NewString(table, "selected")
	s.Site = field.NewString(table, "site")
	s.GitBranchSql = field.NewString(table, "git_branch_sql")
	s.PorjectNameSql = field.NewString(table, "porject_name_sql")
	s.CreateTime = field.NewTime(table, "create_time")
	s.ModifyTime = field.NewTime(table, "modify_time")
	s.Comments = field.NewString(table, "comments")
	s.FlagDel = field.NewString(table, "flag_del")
	s.OrderID = field.NewInt32(table, "order_id")

	s.fillFieldMap()

	return s
}

func (s *sysProjects) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysProjects) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 19)
	s.fieldMap["sys_project_id"] = s.SysProjectID
	s.fieldMap["project_name"] = s.ProjectName
	s.fieldMap["project_code"] = s.ProjectCode
	s.fieldMap["server_ip"] = s.ServerIP
	s.fieldMap["project_leader"] = s.ProjectLeader
	s.fieldMap["zabbix_service_id"] = s.ZabbixServiceID
	s.fieldMap["wechat_id"] = s.WechatID
	s.fieldMap["zabbix_max_maintenance_time"] = s.ZabbixMaxMaintenanceTime
	s.fieldMap["notes"] = s.Notes
	s.fieldMap["jiraspace"] = s.Jiraspace
	s.fieldMap["selected"] = s.Selected
	s.fieldMap["site"] = s.Site
	s.fieldMap["git_branch_sql"] = s.GitBranchSql
	s.fieldMap["porject_name_sql"] = s.PorjectNameSql
	s.fieldMap["create_time"] = s.CreateTime
	s.fieldMap["modify_time"] = s.ModifyTime
	s.fieldMap["comments"] = s.Comments
	s.fieldMap["flag_del"] = s.FlagDel
	s.fieldMap["order_id"] = s.OrderID
}

func (s sysProjects) clone(db *gorm.DB) sysProjects {
	s.sysProjectsDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sysProjects) replaceDB(db *gorm.DB) sysProjects {
	s.sysProjectsDo.ReplaceDB(db)
	return s
}

type sysProjectsDo struct{ gen.DO }

type ISysProjectsDo interface {
	gen.SubQuery
	Debug() ISysProjectsDo
	WithContext(ctx context.Context) ISysProjectsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISysProjectsDo
	WriteDB() ISysProjectsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISysProjectsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysProjectsDo
	Not(conds ...gen.Condition) ISysProjectsDo
	Or(conds ...gen.Condition) ISysProjectsDo
	Select(conds ...field.Expr) ISysProjectsDo
	Where(conds ...gen.Condition) ISysProjectsDo
	Order(conds ...field.Expr) ISysProjectsDo
	Distinct(cols ...field.Expr) ISysProjectsDo
	Omit(cols ...field.Expr) ISysProjectsDo
	Join(table schema.Tabler, on ...field.Expr) ISysProjectsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysProjectsDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysProjectsDo
	Group(cols ...field.Expr) ISysProjectsDo
	Having(conds ...gen.Condition) ISysProjectsDo
	Limit(limit int) ISysProjectsDo
	Offset(offset int) ISysProjectsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysProjectsDo
	Unscoped() ISysProjectsDo
	Create(values ...*model.SysProjects) error
	CreateInBatches(values []*model.SysProjects, batchSize int) error
	Save(values ...*model.SysProjects) error
	First() (*model.SysProjects, error)
	Take() (*model.SysProjects, error)
	Last() (*model.SysProjects, error)
	Find() ([]*model.SysProjects, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysProjects, err error)
	FindInBatches(result *[]*model.SysProjects, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysProjects) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysProjectsDo
	Assign(attrs ...field.AssignExpr) ISysProjectsDo
	Joins(fields ...field.RelationField) ISysProjectsDo
	Preload(fields ...field.RelationField) ISysProjectsDo
	FirstOrInit() (*model.SysProjects, error)
	FirstOrCreate() (*model.SysProjects, error)
	FindByPage(offset int, limit int) (result []*model.SysProjects, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysProjectsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysProjectsDo) Debug() ISysProjectsDo {
	return s.withDO(s.DO.Debug())
}

func (s sysProjectsDo) WithContext(ctx context.Context) ISysProjectsDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysProjectsDo) ReadDB() ISysProjectsDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysProjectsDo) WriteDB() ISysProjectsDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysProjectsDo) Session(config *gorm.Session) ISysProjectsDo {
	return s.withDO(s.DO.Session(config))
}

func (s sysProjectsDo) Clauses(conds ...clause.Expression) ISysProjectsDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysProjectsDo) Returning(value interface{}, columns ...string) ISysProjectsDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysProjectsDo) Not(conds ...gen.Condition) ISysProjectsDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysProjectsDo) Or(conds ...gen.Condition) ISysProjectsDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysProjectsDo) Select(conds ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysProjectsDo) Where(conds ...gen.Condition) ISysProjectsDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysProjectsDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISysProjectsDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s sysProjectsDo) Order(conds ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysProjectsDo) Distinct(cols ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysProjectsDo) Omit(cols ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysProjectsDo) Join(table schema.Tabler, on ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysProjectsDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysProjectsDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysProjectsDo) Group(cols ...field.Expr) ISysProjectsDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysProjectsDo) Having(conds ...gen.Condition) ISysProjectsDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysProjectsDo) Limit(limit int) ISysProjectsDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysProjectsDo) Offset(offset int) ISysProjectsDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysProjectsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysProjectsDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysProjectsDo) Unscoped() ISysProjectsDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysProjectsDo) Create(values ...*model.SysProjects) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysProjectsDo) CreateInBatches(values []*model.SysProjects, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysProjectsDo) Save(values ...*model.SysProjects) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysProjectsDo) First() (*model.SysProjects, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysProjects), nil
	}
}

func (s sysProjectsDo) Take() (*model.SysProjects, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysProjects), nil
	}
}

func (s sysProjectsDo) Last() (*model.SysProjects, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysProjects), nil
	}
}

func (s sysProjectsDo) Find() ([]*model.SysProjects, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysProjects), err
}

func (s sysProjectsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysProjects, err error) {
	buf := make([]*model.SysProjects, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysProjectsDo) FindInBatches(result *[]*model.SysProjects, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysProjectsDo) Attrs(attrs ...field.AssignExpr) ISysProjectsDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysProjectsDo) Assign(attrs ...field.AssignExpr) ISysProjectsDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysProjectsDo) Joins(fields ...field.RelationField) ISysProjectsDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysProjectsDo) Preload(fields ...field.RelationField) ISysProjectsDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysProjectsDo) FirstOrInit() (*model.SysProjects, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysProjects), nil
	}
}

func (s sysProjectsDo) FirstOrCreate() (*model.SysProjects, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysProjects), nil
	}
}

func (s sysProjectsDo) FindByPage(offset int, limit int) (result []*model.SysProjects, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysProjectsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysProjectsDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysProjectsDo) Delete(models ...*model.SysProjects) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysProjectsDo) withDO(do gen.Dao) *sysProjectsDo {
	s.DO = *do.(*gen.DO)
	return s
}
